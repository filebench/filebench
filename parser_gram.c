#ifndef lint
static const char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#include <stdlib.h>
#include <string.h>

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20070509

#define YYEMPTY (-1)
#define yyclearin    (yychar = YYEMPTY)
#define yyerrok      (yyerrflag = 0)
#define YYRECOVERING (yyerrflag != 0)

extern int yyparse(void);

static int yygrowstack(void);
#define YYPREFIX "yy"
#line 30 "parser_gram.y"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <locale.h>
#include <sys/utsname.h>
#include <sys/statvfs.h>
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#ifdef HAVE_LIBTECLA
#include <libtecla.h>
#endif
#include "parsertypes.h"
#include "filebench.h"
#include "utils.h"
#include "stats.h"
#include "vars.h"
#include "eventgen.h"
#ifdef HAVE_LIBTECLA
#include "auto_comp.h"
#endif
#include "multi_client_sync.h"

/* yacc and lex externals */
extern FILE *yyin;
extern int yydebug;
extern void yyerror(char *s);
extern int yylex(void);

/* GetLine resource object */
#ifdef HAVE_LIBTECLA
static GetLine *gl;
#endif

/* executable name to execute worker processes later */
char *execname;

static int dofile = DOFILE_FALSE;
static FILE *parentscript;

static char *fbbasepath = FILEBENCHDIR;
static char cwd[MAXPATHLEN];
static pidlist_t *pidlist;
static int filecreate_done;

/* utilities */
static cmd_t *alloc_cmd(void);
static attr_t *alloc_attr(void);
static attr_t *alloc_lvar_attr(var_t *var);
static attr_t *get_attr(cmd_t *cmd, int64_t name);
static attr_t *get_attr_fileset(cmd_t *cmd, int64_t name);
static attr_t *get_attr_integer(cmd_t *cmd, int64_t name);
static attr_t *get_attr_bool(cmd_t *cmd, int64_t name);
static void get_attr_lvars(cmd_t *cmd, flowop_t *flowop);
static list_t *alloc_list();
static probtabent_t *alloc_probtabent(void);
static void add_lvar_to_list(var_t *newlvar, var_t **lvar_list);

/* Info Commands */
static void parser_list(cmd_t *);
static void parser_flowop_list(cmd_t *);

/* Define Commands */
static void parser_proc_define(cmd_t *);
static void parser_thread_define(cmd_t *, procflow_t *, int instances);
static void parser_flowop_define(cmd_t *, threadflow_t *, flowop_t **, int);
static void parser_file_define(cmd_t *);
static void parser_fileset_define(cmd_t *);
static void parser_posset_define(cmd_t *);
static void parser_randvar_define(cmd_t *);
static void parser_randvar_set(cmd_t *);
static void parser_composite_flowop_define(cmd_t *);

/* Create Commands */
static void parser_proc_create(cmd_t *);
static void parser_fileset_create(cmd_t *);

/* set commands */
static void parser_set_integer(cmd_t *cmd);
static void parser_set_var(cmd_t *cmd);
static void parser_set_var_op_int(cmd_t *cmd);
static void parser_set_int_op_var(cmd_t *cmd);
static void parser_set_var_op_var(cmd_t *cmd);

/* Shutdown Commands */
static void parser_proc_shutdown(cmd_t *);
static void parser_filebench_shutdown(cmd_t *cmd);
static void parser_fileset_shutdown(cmd_t *cmd);

/* Other Commands */
static void parser_echo(cmd_t *cmd);
static void parser_foreach_integer(cmd_t *cmd);
static void parser_foreach_string(cmd_t *cmd);
static void parser_fscheck(cmd_t *cmd);
static void parser_fsflush(cmd_t *cmd);
static void parser_log(cmd_t *cmd);
static void parser_statscmd(cmd_t *cmd);
static void parser_statsdump(cmd_t *cmd);
static void parser_statsxmldump(cmd_t *cmd);
static void parser_statsmultidump(cmd_t *cmd);
static void parser_usage(cmd_t *cmd);
static void parser_vars(cmd_t *cmd);
static void parser_printvars(cmd_t *cmd);
static void parser_system(cmd_t *cmd);
static void parser_statssnap(cmd_t *cmd);
static void parser_directory(cmd_t *cmd);
static void parser_eventgen(cmd_t *cmd);
static void parser_enable_mc(cmd_t *cmd);
static void parser_domultisync(cmd_t *cmd);
static void parser_run(cmd_t *cmd);
static void parser_run_variable(cmd_t *cmd);
static void parser_sleep(cmd_t *cmd);
static void parser_sleep_variable(cmd_t *cmd);
static void parser_warmup(cmd_t *cmd);
static void parser_warmup_variable(cmd_t *cmd);
static void parser_help(cmd_t *cmd);
static void arg_parse(const char *command);
static void parser_abort(int arg);
static void parser_version(cmd_t *cmd);
static void parser_osprof_enable(cmd_t *cmd);
static void parser_osprof_disable(cmd_t *cmd);

#line 161 "parser_gram.y"
typedef union {
	int64_t		 ival;
	unsigned char	 bval;
	char *		 sval;
	fs_u		 val;
	avd_t		 avd;
	cmd_t		*cmd;
	attr_t		*attr;
	list_t		*list;
	probtabent_t	*rndtb;
} YYSTYPE;
#line 165 "parser_gram.c"
#define FSC_LIST 257
#define FSC_DEFINE 258
#define FSC_EXEC 259
#define FSC_QUIT 260
#define FSC_DEBUG 261
#define FSC_CREATE 262
#define FSC_SLEEP 263
#define FSC_STATS 264
#define FSC_FOREACH 265
#define FSC_SET 266
#define FSC_SHUTDOWN 267
#define FSC_LOG 268
#define FSC_SYSTEM 269
#define FSC_FLOWOP 270
#define FSC_EVENTGEN 271
#define FSC_ECHO 272
#define FSC_LOAD 273
#define FSC_RUN 274
#define FSC_WARMUP 275
#define FSC_NOUSESTATS 276
#define FSC_FSCHECK 277
#define FSC_FSFLUSH 278
#define FSC_USAGE 279
#define FSC_HELP 280
#define FSC_VARS 281
#define FSC_VERSION 282
#define FSC_ENABLE 283
#define FSC_DOMULTISYNC 284
#define FSV_STRING 285
#define FSV_VAL_INT 286
#define FSV_VAL_BOOLEAN 287
#define FSV_VARIABLE 288
#define FSV_WHITESTRING 289
#define FSV_RANDUNI 290
#define FSV_RANDTAB 291
#define FSV_RANDVAR 292
#define FSV_URAND 293
#define FSV_RAND48 294
#define FST_INT 295
#define FST_BOOLEAN 296
#define FSE_FILE 297
#define FSE_PROC 298
#define FSE_THREAD 299
#define FSE_CLEAR 300
#define FSE_ALL 301
#define FSE_SNAP 302
#define FSE_DUMP 303
#define FSE_DIRECTORY 304
#define FSE_COMMAND 305
#define FSE_FILESET 306
#define FSE_POSSET 307
#define FSE_XMLDUMP 308
#define FSE_RAND 309
#define FSE_MODE 310
#define FSE_MULTI 311
#define FSE_MULTIDUMP 312
#define FSK_SEPLST 313
#define FSK_OPENLST 314
#define FSK_CLOSELST 315
#define FSK_ASSIGN 316
#define FSK_IN 317
#define FSK_QUOTE 318
#define FSK_DIRSEPLST 319
#define FSK_PLUS 320
#define FSK_MINUS 321
#define FSK_MULTIPLY 322
#define FSK_DIVIDE 323
#define FSA_SIZE 324
#define FSA_PREALLOC 325
#define FSA_PARALLOC 326
#define FSA_PATH 327
#define FSA_REUSE 328
#define FSA_PROCESS 329
#define FSA_MEMSIZE 330
#define FSA_RATE 331
#define FSA_CACHED 332
#define FSA_READONLY 333
#define FSA_TRUSTTREE 334
#define FSA_IOSIZE 335
#define FSA_FILE 336
#define FSA_POSSET 337
#define FSA_WSS 338
#define FSA_NAME 339
#define FSA_RANDOM 340
#define FSA_INSTANCES 341
#define FSA_DSYNC 342
#define FSA_TARGET 343
#define FSA_ITERS 344
#define FSA_NICE 345
#define FSA_VALUE 346
#define FSA_BLOCKING 347
#define FSA_HIGHWATER 348
#define FSA_DIRECTIO 349
#define FSA_DIRWIDTH 350
#define FSA_FD 351
#define FSA_SRCFD 352
#define FSA_ROTATEFD 353
#define FSA_NAMELENGTH 354
#define FSA_FILESIZE 355
#define FSA_ENTRIES 356
#define FSA_FILESIZEGAMMA 357
#define FSA_DIRDEPTHRV 358
#define FSA_DIRGAMMA 359
#define FSA_USEISM 360
#define FSA_TYPE 361
#define FSA_RANDTABLE 362
#define FSA_RANDSRC 363
#define FSA_RANDROUND 364
#define FSA_LEAFDIRS 365
#define FSA_INDEXED 366
#define FSA_FSTYPE 367
#define FSA_RANDSEED 368
#define FSA_RANDGAMMA 369
#define FSA_RANDMEAN 370
#define FSA_RANDMIN 371
#define FSA_RANDMAX 372
#define FSA_MASTER 373
#define FSA_CLIENT 374
#define FSS_TYPE 375
#define FSS_SEED 376
#define FSS_GAMMA 377
#define FSS_MEAN 378
#define FSS_MIN 379
#define FSS_SRC 380
#define FSS_ROUND 381
#define FSV_SET_LOCAL_VAR 382
#define FSA_LVAR_ASSIGN 383
#define FSA_ALLDONE 384
#define FSA_FIRSTDONE 385
#define FSA_TIMEOUT 386
#define FSC_OSPROF_ENABLE 387
#define FSC_OSPROF_DISABLE 388
#define FSA_NOREADAHEAD 389
#define FSA_IOPRIO 390
#define FSA_WRITEONLY 391
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    0,    5,    5,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,   20,   20,   20,   66,
   66,   67,   67,   24,   24,   22,   29,   33,   41,   42,
   30,   32,   34,   34,   35,   68,   68,   70,   70,   69,
   69,   69,   69,   69,   71,   71,   72,   72,   72,   72,
   72,   72,   72,   72,    8,    8,   37,   37,   38,   21,
   14,   18,   18,   39,   39,   39,   39,   40,   40,   40,
   40,   40,   40,   40,   40,   40,   40,   17,   17,   17,
   17,   17,   17,   17,   25,   26,   26,   28,   27,   27,
    9,    9,   10,   10,   10,   11,   11,   12,   13,   13,
   15,   19,   36,   36,   16,   16,    7,    7,    7,   31,
   23,   23,    6,    2,    2,    2,    2,    3,    3,    3,
    1,   44,   44,   45,   45,   46,   46,   43,   43,   54,
   54,   54,   53,   53,   53,   53,   95,   94,   94,   48,
   48,   47,   47,   50,   50,   50,   49,   49,   52,   52,
   51,   51,   62,   62,   63,   64,   65,   93,   93,   93,
   93,   81,   81,   82,   83,   83,   84,   85,   78,   78,
   78,   73,   73,   73,   73,   73,   73,   73,   73,   73,
   76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
   76,   76,   76,   76,   76,   76,   77,   77,   77,   77,
   77,   86,   86,   86,   86,   86,   86,   90,   90,   90,
   90,   90,   90,   90,   88,   88,   88,   88,   88,   55,
   87,   87,   87,   56,   89,   89,   74,   74,   74,   74,
   74,   74,   75,   75,   75,   75,   75,   75,   75,   75,
   75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
   79,   91,   91,   92,   92,   61,   61,   61,   60,   59,
   59,   59,   59,   59,   59,   80,   80,   57,   57,   57,
   57,   58,   58,   58,   58,   58,   96,   96,
};
short yylen[] = {                                         2,
    2,    2,    0,    1,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    7,    7,    1,
    3,    3,    5,    1,    2,    2,    2,    1,    1,    1,
    2,    1,    2,    2,    2,    1,    3,    1,    1,    1,
    2,    2,    2,    2,    2,    2,    2,    2,    3,    2,
    2,    3,    2,    2,    1,    2,    2,    2,    2,    2,
    2,    1,    1,    4,    4,    3,    3,    4,    6,    4,
    4,    4,    4,    3,    5,    5,    5,    2,    2,    3,
    3,    3,    3,    3,    1,    1,    2,    5,    1,    2,
    6,    2,    2,    2,    2,    2,    2,    3,    6,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    1,    1,
    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    3,    1,    3,    3,    1,    3,    1,    1,
    3,    7,    3,    1,    3,    3,    7,    1,    3,    1,
    3,    3,    1,    1,    3,    3,    3,    1,    1,    3,
    3,    1,    1,    3,    3,    3,    3,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    3,    3,    3,    3,
    3,    5,    3,    3,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,
};
short yydefred[] = {                                      3,
    0,    2,   75,    0,  105,    0,    0,    0,    0,   37,
    0,    0,    0,    0,   44,    0,    0,    0,    0,    0,
    0,    0,  130,   52,   48,    0,    0,   49,   50,    1,
   22,   24,    0,    0,    0,    0,    9,    0,   11,   13,
   27,   29,   25,   26,    0,   23,   30,    0,   36,   14,
   15,   20,   16,   31,    0,   35,   28,    0,   19,    0,
   83,   32,   33,    0,  113,    0,  114,  116,    0,   81,
  137,  134,  135,  136,  121,  125,  126,   99,   98,    0,
    0,    0,    0,    0,    0,    0,    0,  122,    0,    0,
    0,    0,    0,  133,  127,  128,  123,  124,  274,  275,
   77,    0,   79,    0,   53,    0,   55,   76,  247,  249,
  190,  191,  189,  250,  252,  160,    0,  185,  186,    0,
  192,  198,  199,  194,  197,  213,  195,  196,  193,  204,
  214,  211,  205,  212,  215,  200,  142,    0,  182,  183,
    0,  217,  220,  218,  219,  221,    0,  144,  184,    0,
  286,  287,  276,    0,    0,    0,  271,  169,    0,  188,
    0,  272,  273,    0,  173,    0,   78,  178,  179,  180,
  181,    0,    0,    0,  222,    0,    0,  227,  223,  224,
  225,  226,  150,    0,    0,    0,   59,   58,    0,    0,
    0,    0,    0,    0,    0,  235,  236,  237,  238,    0,
  239,    0,    0,   94,   65,   66,   68,   67,    0,   74,
   71,   70,    0,   73,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   86,
   87,    0,    0,    0,    0,    0,    0,   63,   64,   61,
   62,   90,   84,   88,   85,    0,    0,    0,    0,   92,
   93,   91,  228,  230,  231,  232,  233,  229,  234,   69,
   72,  177,  288,  289,  290,  291,  176,  161,  162,  143,
   59,  294,  295,   58,  148,    0,  145,  146,    0,  278,
  277,  279,   40,    0,    0,    0,  170,  171,  174,  175,
    0,    0,    0,    0,    0,  109,  241,  242,  243,  155,
  240,  245,  246,  156,  244,    0,  151,  153,    0,   95,
   96,   97,    0,    0,    0,    0,    0,    0,  141,  131,
  269,  254,  255,  253,  256,  257,  261,  264,  265,  266,
  267,  268,  262,  258,  259,  260,  263,  270,  164,    0,
  187,    0,  119,    0,    0,  111,  110,    0,   89,  283,
  281,  280,  284,    0,   42,   41,    4,    0,    0,    0,
    0,    0,    0,    0,    0,   38,    5,    0,   39,  165,
  166,  167,    0,    0,    0,  158,  282,   43,  108,  297,
  298,    0,    0,  152,    0,  159,    0,    0,    0,  157,
};
short yydgoto[] = {                                       1,
  320,   75,    0,  357,  358,   31,   32,   33,   34,   35,
   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,
   46,   47,  292,   48,   49,  293,  295,  296,   50,   51,
   52,   53,   54,   55,   56,   57,   58,   59,   60,   61,
   62,   63,  137,  138,  147,  148,  116,  117,  339,  340,
  158,  159,  183,  184,  300,  304,  267,  275,  280,  153,
  154,  164,  165,  107,  101,  285,  286,    0,  276,  190,
   90,   91,  139,  118,  341,  140,  149,  119,  160,  155,
  141,  150,  120,  342,  161,  185,  301,  202,  305,  260,
  166,  102,  172,  375,  376,  382,
};
short yysindex[] = {                                      0,
 -237,    0,    0, -132,    0, -280,   33,  -57,   44,    0,
 -128,   33, -257, -257,    0, -257, -123,  -42,   35, -186,
 -186, -257,    0,    0,    0, -144, -148,    0,    0,    0,
    0,    0,  -31, -197,  101, -136,    0, -329,    0,    0,
    0,    0,    0,    0,  -84,    0,    0,  -86,    0,    0,
    0,    0,    0,    0, -163,    0,    0, -186,    0,  116,
    0,    0,    0, -329,    0, -197,    0,    0,  -51,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -257,
 -145, -257, -257, -257,  -64,   -1, -115,    0,  -33,  -80,
  -65,  -65,  -65,    0,    0,    0,    0,    0,    0,    0,
    0,  -56,    0,  -65,    0,  -19,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  -12,    0,    0,  -10,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   -2,    0,    0,
    8,    0,    0,    0,    0,    0,    2,    0,    0,   21,
    0,    0,    0,   29,   34,   38,    0,    0,   59,    0,
   74,    0,    0,   78,    0,   80,    0,    0,    0,    0,
    0,   50,  -27,  -24,    0,   91,  106,    0,    0,    0,
    0,    0,    0,  110,  108,  -65,    0,    0,  -55,  -34,
  -65,  -65,  -65, -129,  114,    0,    0,    0,    0,  115,
    0,  138, -232,    0,    0,    0,    0,    0,    6,    0,
    0,    0,    6,    0,  147,  156, -197,  156,  101,  160,
 -136,  160, -171,  156, -279,  -86,  156, -163,  156,    0,
    0,  179,  154, -274,   60, -121,  160,    0,    0,    0,
    0,    0,    0,    0,    0,  166, -274,   60,  156,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -55,    0,    0,  140,    0,
    0,    0,    0,  178,   51,   54,    0,    0,    0,    0,
  183,  228, -265, -197,  -94,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  157,    0,    0,  159,    0,
    0,    0, -116,  161,  186, -153,  162, -153,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  165,
    0,  158,    0,  228,   57,    0,    0,  167,    0,    0,
    0,    0,    0,  193,    0,    0,    0, -209,  194, -181,
 -152,  156,  179,  170,  168,    0,    0,  171,    0,    0,
    0,    0, -248,   55, -301,    0,    0,    0,    0,    0,
    0,  172,  170,    0,   55,    0,  175,   55,  176,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 1391,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1452, 1481, 1537, 1614,    0, 1676,    0,    0,
    0,    0,    0,    0, 1705,    0,    0, 1766,    0,    0,
    0,    0,    0,    0, 1841,    0,    0, 1901,    0, 1930,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 1975, 2065, 2126,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 2155,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  643,    0,    0,  553,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  413,    0,    0,
  277,    0,    0,    0,    0,    0,  947,    0,    0,  878,
    0,    0,    0, 1085,    0,    0,    0,    0, 1251,    0,
 1115,    0,    0, 1176,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 2200, 1312, 2291,    0,    0, 2351,    1,
 2381, 2442, 2516,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  137,    0,    0,  744,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -192,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  -44,
    0,  932,    0, -135,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
    0,  463,    0,    3,  181,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, -284,    0,    0,  127,    0,  202,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  281,    0,    0,  280,  286,  -66,  143,    0,
  282,    0,  270,    0,  260,  262, -216, -219,  150,  289,
  449,    0,  287,    0,  118,    0,    0,    0,  433,    0,
    0,  133,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  303,
    0,    0,    0,    0,  134, -166,
};
#define YYTABLESIZE 2904
short yytable[] = {                                     174,
   60,  269,  278,   30,  291,   70,  283,  282,  344,  151,
  288,  383,  290,  384,  152,  297,  298,  308,    2,    3,
    4,  291,    5,    6,    7,    8,    9,   10,   11,   12,
   13,   14,  312,   15,   16,   17,   18,   19,  284,   20,
   21,   22,   23,   24,   25,   26,   27,    3,    4,  343,
    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
   89,   15,   16,   17,   18,   19,  379,   20,   21,   22,
   23,   24,   25,   26,   27,    3,    4,  106,    5,    6,
    7,    8,    9,   10,   11,   12,   13,   14,  344,   15,
   16,   17,   18,   19,  299,   20,   21,   22,   23,   24,
   25,   26,   27,    3,    4,  366,    5,    6,    7,    8,
    9,   10,   11,   12,   13,   14,  279,   15,   16,   17,
   18,   19,  106,   20,   21,   22,   23,   24,   25,   26,
   27,  109,  110,  369,  107,  279,  292,   64,  103,  187,
   99,  111,  188,  112,  203,  372,   92,  113,   93,   28,
   29,  250,  251,  252,  104,  242,  243,  244,  245,   85,
  204,   94,  114,   86,   65,   66,  105,  151,  350,  351,
  352,  353,  152,   67,   68,  167,   69,   28,   29,  107,
  100,   87,  321,  322,  323,  324,  325,  326,  246,  327,
  328,  329,  115,  330,  331,  332,  333,  106,  334,  335,
  336,  354,  142,  156,  294,   28,   29,  207,  208,  162,
  163,  209,  186,  337,  191,  192,  193,  175,  387,  143,
  346,  389,  211,  212,  144,  132,  213,  345,   76,  238,
   77,  145,  239,   28,   29,  146,  338,  210,  108,  176,
  306,  177,  178,   95,  157,   96,  179,  180,  181,  182,
  240,  194,  214,  241,  205,  206,   60,   60,   60,  215,
   60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
  132,   60,   60,   60,   60,   60,  149,   60,   60,   60,
   60,   60,   60,   60,   60,  223,  232,  175,  217,  233,
  132,  132,  132,  132,  132,  132,  216,  132,  132,  132,
  217,  132,  132,  132,  132,  218,  132,  132,  132,  176,
  219,  177,  178,   60,  221,   60,  179,  180,  181,  182,
   97,  132,   98,  220,   60,   60,   60,   60,   60,   71,
   72,   73,   60,   60,   60,  230,  222,  231,   74,   60,
  380,  223,  381,   78,  132,   79,   80,   81,   82,  224,
   60,   83,  302,  303,  225,   84,   60,   60,   60,   60,
  367,   60,  367,  315,  316,   60,  317,  318,   60,  217,
  363,  226,   60,  195,  196,  197,  198,  199,  200,  201,
  253,  254,  255,  256,  257,  258,  259,   60,   60,  227,
  228,   60,  292,  292,  292,  229,  292,  292,  292,  292,
  292,  292,  292,  292,  292,  292,  234,  292,  292,  292,
  292,  292,  115,  292,  292,  292,  292,  292,  292,  292,
  292,  235,  236,  237,  121,  122,  123,  124,  125,  247,
  248,  262,  126,  127,  128,  168,  169,  170,  171,  129,
  263,  264,  265,  266,  271,  272,  273,  274,  291,  292,
  130,  292,  294,  249,  309,  313,  131,  132,  133,  134,
  292,  292,  292,  292,  292,  135,  314,  319,  292,  292,
  292,  356,  348,  362,   88,  292,  349,  361,  355,  359,
  364,  365,  368,  374,  385,  377,  292,  388,  378,  373,
  390,  136,  292,  292,  292,  292,  347,  292,  360,  270,
  277,  292,  268,  370,  292,  307,  310,  287,  292,  311,
  371,  281,  173,  189,  289,  261,  386,    0,    0,    0,
    0,    0,    0,  292,  292,    0,    0,  292,    0,    0,
    0,    0,  149,  149,  149,    0,  149,  149,  149,  149,
  149,  149,  149,  149,  149,  149,    0,  149,  149,  149,
  149,  149,  163,  149,  149,  149,  149,  149,  149,  149,
  149,    0,  321,  322,  323,  324,  325,  326,    0,  327,
  328,  329,    0,  330,  331,  332,  333,    0,  334,  335,
  336,    0,    0,    0,    0,    0,    0,    0,    0,  149,
    0,  149,    0,  337,    0,    0,    0,    0,    0,    0,
  149,  149,  149,  149,  149,    0,    0,    0,  149,  149,
  149,    0,    0,    0,    0,  149,  338,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  149,    0,    0,    0,
    0,    0,  149,  149,  149,  149,    0,    0,    0,    0,
    0,  149,  112,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  149,  149,    0,    0,  149,  115,  115,
  115,    0,  115,  115,  115,  115,  115,  115,  115,  115,
  115,  115,    0,  115,  115,  115,  115,  115,    0,  115,
  115,  115,  115,  115,  115,  115,  115,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  115,    0,    0,
    0,    0,    0,    0,    0,    0,  115,  115,  115,  115,
  115,    0,    0,  285,  115,  115,  115,    0,    0,    0,
    0,  115,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  115,    0,    0,    0,    0,    0,  115,  115,
  115,  115,    0,    0,    0,    0,    0,  115,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  115,
  115,    0,    0,  115,    0,    0,    0,    0,  163,  163,
  163,    0,  163,  163,  163,  163,  163,  163,  163,  163,
  163,  163,    0,  163,  163,  163,  163,  163,    0,  163,
  163,  163,  163,  163,  163,  163,  163,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  163,  163,  163,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  147,    0,    0,
    0,  163,  163,    0,    0,    0,    0,    0,    0,    0,
    0,  163,    0,  163,    0,    0,    0,  163,  112,  112,
  112,    0,  112,  112,  112,  112,  112,  112,  112,  112,
  112,  112,  163,  112,  112,  112,  112,  112,    0,  112,
  112,  112,  112,  112,  112,  112,  112,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  163,
  163,    0,  163,    0,    0,    0,  117,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  112,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  112,  112,    0,    0,    0,    0,    0,    0,    0,
    0,  112,    0,  112,    0,    0,    0,  112,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  285,
  285,  285,  112,  285,  285,  285,  285,  285,  285,  285,
  285,  285,  285,  285,  285,  285,  285,  285,  285,    0,
  285,  285,  285,  285,  285,  285,  285,  285,    0,  112,
  112,    0,  112,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  285,  285,  285,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  285,  285,
  285,  285,  285,  285,  120,  285,  285,  285,    0,  285,
  285,  285,  285,    0,  285,  285,  285,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  285,
    0,    0,    0,    0,  172,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  285,  285,  285,  147,  147,  147,    0,  147,  147,  147,
  147,  147,  147,  147,  147,  147,  147,    0,  147,  147,
  147,  147,  147,    0,  147,  147,  147,  147,  147,  147,
  147,  147,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  147,    0,  147,    0,    0,    0,    0,    0,    0,    0,
    0,  168,  117,  117,  117,    0,  117,  117,  117,  117,
  117,  117,  117,  117,  117,  117,  147,  117,  117,  117,
  117,  117,    0,  117,  117,  117,  117,  117,  117,  117,
  117,    0,    0,  147,    0,    0,    0,    0,  147,    0,
    0,    0,    0,    0,  168,  147,  168,    0,    0,  147,
   45,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  117,    0,    0,  147,  147,  168,  168,  168,  168,
  168,  168,    0,  168,  168,  168,    0,  168,  168,  168,
  168,    0,  168,  168,  168,  117,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  168,    0,    0,
    0,    0,  117,    0,    0,    0,    0,  117,    0,    0,
    0,  154,    0,    0,  117,    0,    0,    0,  117,    0,
  168,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  117,  117,    0,    0,    0,    0,    0,
  120,  120,  120,    0,  120,  120,  120,  120,  120,  120,
  120,  120,  120,  120,    0,  120,  120,  120,  120,  120,
    0,  120,  120,  120,  120,  120,  120,  120,  120,    0,
  172,  172,  172,    0,  172,  172,  172,  172,  172,  172,
  172,  172,  172,  172,    0,  172,  172,  172,  172,  172,
  129,  172,  172,  172,  172,  172,  172,  172,  172,  120,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  120,    0,    0,    0,  172,  120,  172,
    0,   54,   54,   54,    0,   54,   54,   54,   54,   54,
   54,   54,   54,   54,   54,  172,   54,   54,   54,   54,
   54,   21,   54,   54,   54,   54,   54,   54,   54,   54,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  120,  120,    0,    0,    0,    0,    0,    0,    0,
    6,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   54,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  172,  172,    0,    0,    0,   45,   45,   45,    0,
   45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
    0,   45,   45,   45,   45,   45,    0,   45,   45,   45,
   45,   45,   45,   45,   45,    0,    7,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   54,   54,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   54,   54,    0,   45,    0,  154,  154,  154,
    0,  154,  154,  154,  154,  154,  154,  154,  154,  154,
  154,   45,  154,  154,  154,  154,  154,    0,  154,  154,
  154,  154,  154,  154,  154,  154,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    8,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  154,    0,  154,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   45,   45,    0,
    0,    0,    0,    0,    0,    0,  129,  129,  129,    0,
  129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
    0,  129,  129,  129,  129,  129,    0,  129,  129,  129,
  129,  129,  129,  129,  129,   10,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  154,  154,
    0,    0,    0,    0,   17,  129,    0,   21,   21,   21,
    0,   21,   21,   21,   21,   21,   21,   21,   21,   21,
   21,    0,   21,   21,   21,   21,   21,    0,   21,   21,
   21,   21,   21,   21,   21,   21,    6,    6,    6,    0,
    6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
    0,    6,    6,    6,    6,    6,    0,    6,    6,    6,
    6,    6,    6,    6,    6,   12,   21,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  129,  129,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    7,    7,    7,    6,    7,    7,    7,    7,
    7,    7,    7,    7,    7,    7,    0,    7,    7,    7,
    7,    7,    0,    7,    7,    7,    7,    7,    7,    7,
    7,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   21,   21,
   34,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    7,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    6,    6,    8,
    8,    8,    0,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    0,    8,    8,    8,    8,    8,    0,
    8,    8,    8,    8,    8,    8,    8,    8,    0,    0,
   18,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    7,    7,    0,    0,    0,    8,   82,
    0,   10,   10,   10,    0,   10,   10,   10,   10,   10,
   10,   10,   10,   10,   10,    0,   10,   10,   10,   10,
   10,    0,   10,   10,   10,   10,   10,   10,   10,   10,
   17,   17,   17,    0,   17,   17,   17,   17,   17,   17,
   17,   17,   17,   17,   80,   17,   17,   17,   17,   17,
    0,   17,   17,   17,   17,   17,   17,   17,   17,    0,
   10,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    8,    8,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   17,
    0,   12,   12,   12,    0,   12,   12,   12,   12,   12,
   12,   12,   12,   12,   12,    0,   12,   12,   12,   12,
   12,    0,   12,   12,   12,   12,   12,   12,   12,   12,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   10,   10,   46,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   12,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   17,   17,    0,    0,    0,   34,   34,   34,    0,
   34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
    0,   34,   34,   34,   34,   34,    0,   34,   34,   34,
   34,   34,   34,   34,   34,   47,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   12,   12,   51,   34,   18,   18,   18,    0,
   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
    0,   18,   18,   18,   18,   18,    0,   18,   18,   18,
   18,   18,   18,   18,   18,   82,   82,   82,    0,   82,
   82,   82,   82,   82,   82,   82,   82,   82,   82,  118,
   82,   82,   82,   82,   82,    0,   82,   82,   82,   82,
   82,   82,   82,   82,    0,   18,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   34,   34,    0,
   80,   80,   80,    0,   80,   80,   80,   80,   80,   80,
   80,   80,   80,   80,   82,   80,   80,   80,   80,   80,
    0,   80,   80,   80,   80,   80,   80,   80,   80,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   18,   18,   80,
  102,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   82,   82,    0,    0,
   46,   46,   46,    0,   46,   46,   46,   46,   46,   46,
   46,   46,   46,   46,    0,   46,   46,   46,   46,   46,
    0,   46,   46,   46,   46,   46,   46,   46,   46,    0,
  100,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   80,   80,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   46,
  101,   47,   47,   47,    0,   47,   47,   47,   47,   47,
   47,   47,   47,   47,   47,    0,   47,   47,   47,   47,
   47,    0,   47,   47,   47,   47,   47,   47,   47,   47,
   51,   51,   51,    0,   51,   51,   51,   51,   51,   51,
   51,   51,   51,   51,    0,   51,   51,   51,   51,   51,
    0,   51,   51,   51,   51,   51,   51,   51,   51,    0,
   47,  103,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   46,   46,    0,    0,  118,  118,  118,    0,  118,
  118,  118,  118,  118,  118,  118,  118,  118,  118,   51,
  118,  118,  118,  118,  118,    0,  118,  118,  118,  118,
  118,  118,  118,  118,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   47,   47,  118,  104,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   51,   51,    0,    0,    0,  102,  102,  102,    0,
  102,  102,  102,  102,  102,  102,  102,  102,  102,  102,
    0,  102,  102,  102,  102,  102,    0,  102,  102,  102,
  102,  102,  102,  102,  102,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  118,  118,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  102,  100,  100,  100,    0,
  100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
    0,  100,  100,  100,  100,  100,    0,  100,  100,  100,
  100,  100,  100,  100,  100,    0,  101,  101,  101,    0,
  101,  101,  101,  101,  101,  101,  101,  101,  101,  101,
    0,  101,  101,  101,  101,  101,    0,  101,  101,  101,
  101,  101,  101,  101,  101,  100,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  102,  102,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  101,    0,  103,  103,  103,
    0,  103,  103,  103,  103,  103,  103,  103,  103,  103,
  103,    0,  103,  103,  103,  103,  103,    0,  103,  103,
  103,  103,  103,  103,  103,  103,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  100,  100,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  103,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  101,  101,    0,
    0,  104,  104,  104,    0,  104,  104,  104,  104,  104,
  104,  104,  104,  104,  104,    0,  104,  104,  104,  104,
  104,    0,  104,  104,  104,  104,  104,  104,  104,  104,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  103,  103,
  104,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  104,  104,
};
short yycheck[] = {                                      66,
    0,  218,  222,    1,  270,  286,  286,  224,  293,  339,
  227,  313,  229,  315,  344,  290,  291,  237,  256,  257,
  258,  270,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  249,  271,  272,  273,  274,  275,  318,  277,
  278,  279,  280,  281,  282,  283,  284,  257,  258,  315,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  318,  271,  272,  273,  274,  275,  315,  277,  278,  279,
  280,  281,  282,  283,  284,  257,  258,  270,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,  373,  271,
  272,  273,  274,  275,  369,  277,  278,  279,  280,  281,
  282,  283,  284,  257,  258,  315,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  288,  271,  272,  273,
  274,  275,  315,  277,  278,  279,  280,  281,  282,  283,
  284,  329,  330,  315,  270,  288,    0,  270,   21,  285,
  327,  339,  288,  341,  260,  362,   14,  345,   16,  387,
  388,  384,  385,  386,   22,  285,  286,  287,  288,  288,
  276,  285,  360,  292,  297,  298,  311,  339,  285,  286,
  287,  288,  344,  306,  307,   58,  309,  387,  388,  315,
  367,  310,  335,  336,  337,  338,  339,  340,  318,  342,
  343,  344,  390,  346,  347,  348,  349,  346,  351,  352,
  353,  318,  339,  288,  299,  387,  388,  288,  289,  373,
  374,  292,   80,  366,   82,   83,   84,  339,  385,  356,
  315,  388,  288,  289,  361,  270,  292,  294,  286,  285,
  288,  368,  288,  387,  388,  372,  389,  318,  270,  361,
  362,  363,  364,  286,  331,  288,  368,  369,  370,  371,
  285,  316,  318,  288,  288,  289,  256,  257,  258,  316,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  315,  271,  272,  273,  274,  275,    0,  277,  278,  279,
  280,  281,  282,  283,  284,  313,  314,  339,  313,  314,
  335,  336,  337,  338,  339,  340,  316,  342,  343,  344,
  313,  346,  347,  348,  349,  316,  351,  352,  353,  361,
  313,  363,  364,  313,  313,  315,  368,  369,  370,  371,
  286,  366,  288,  316,  324,  325,  326,  327,  328,  297,
  298,  299,  332,  333,  334,  286,  316,  288,  306,  339,
  286,  313,  288,  300,  389,  302,  303,  304,  305,  316,
  350,  308,  293,  294,  317,  312,  356,  357,  358,  359,
  358,  361,  360,  313,  314,  365,  313,  314,  368,  313,
  314,  313,  372,  375,  376,  377,  378,  379,  380,  381,
  375,  376,  377,  378,  379,  380,  381,  387,  388,  316,
  313,  391,  256,  257,  258,  316,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  316,  271,  272,  273,
  274,  275,    0,  277,  278,  279,  280,  281,  282,  283,
  284,  316,  313,  316,  324,  325,  326,  327,  328,  316,
  316,  285,  332,  333,  334,  320,  321,  322,  323,  339,
  285,  286,  287,  288,  285,  286,  287,  288,  270,  313,
  350,  315,  299,  316,  289,  316,  356,  357,  358,  359,
  324,  325,  326,  327,  328,  365,  289,  285,  332,  333,
  334,  286,  316,  316,   12,  339,  318,  313,  318,  318,
  314,  289,  289,  314,  313,  318,  350,  313,  318,  363,
  315,  391,  356,  357,  358,  359,  295,  361,  318,  219,
  221,  365,  217,  361,  368,  236,  247,  226,  372,  248,
  361,  223,   64,   81,  228,  213,  383,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,   -1,  391,   -1,   -1,
   -1,   -1,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,    0,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,  335,  336,  337,  338,  339,  340,   -1,  342,
  343,  344,   -1,  346,  347,  348,  349,   -1,  351,  352,
  353,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,
   -1,  315,   -1,  366,   -1,   -1,   -1,   -1,   -1,   -1,
  324,  325,  326,  327,  328,   -1,   -1,   -1,  332,  333,
  334,   -1,   -1,   -1,   -1,  339,  389,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  350,   -1,   -1,   -1,
   -1,   -1,  356,  357,  358,  359,   -1,   -1,   -1,   -1,
   -1,  365,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,   -1,  391,  256,  257,
  258,   -1,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,   -1,  271,  272,  273,  274,  275,   -1,  277,
  278,  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  324,  325,  326,  327,
  328,   -1,   -1,    0,  332,  333,  334,   -1,   -1,   -1,
   -1,  339,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  350,   -1,   -1,   -1,   -1,   -1,  356,  357,
  358,  359,   -1,   -1,   -1,   -1,   -1,  365,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,
  388,   -1,   -1,  391,   -1,   -1,   -1,   -1,  256,  257,
  258,   -1,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,   -1,  271,  272,  273,  274,  275,   -1,  277,
  278,  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  313,  314,  315,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,
   -1,  329,  330,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  339,   -1,  341,   -1,   -1,   -1,  345,  256,  257,
  258,   -1,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  360,  271,  272,  273,  274,  275,   -1,  277,
  278,  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,
  388,   -1,  390,   -1,   -1,   -1,    0,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  329,  330,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  339,   -1,  341,   -1,   -1,   -1,  345,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  256,
  257,  258,  360,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,  270,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,  387,
  388,   -1,  390,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  313,  314,  315,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  335,  336,
  337,  338,  339,  340,    0,  342,  343,  344,   -1,  346,
  347,  348,  349,   -1,  351,  352,  353,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  366,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  387,  388,  389,  256,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,   -1,  271,  272,
  273,  274,  275,   -1,  277,  278,  279,  280,  281,  282,
  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  313,   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  270,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  339,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,   -1,  356,   -1,   -1,   -1,   -1,  361,   -1,
   -1,   -1,   -1,   -1,  313,  368,  315,   -1,   -1,  372,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  315,   -1,   -1,  387,  388,  335,  336,  337,  338,
  339,  340,   -1,  342,  343,  344,   -1,  346,  347,  348,
  349,   -1,  351,  352,  353,  339,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  366,   -1,   -1,
   -1,   -1,  356,   -1,   -1,   -1,   -1,  361,   -1,   -1,
   -1,    0,   -1,   -1,  368,   -1,   -1,   -1,  372,   -1,
  389,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
    0,  277,  278,  279,  280,  281,  282,  283,  284,  315,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  339,   -1,   -1,   -1,  313,  344,  315,
   -1,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,  331,  271,  272,  273,  274,
  275,    0,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,    0,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  373,  374,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,   -1,  315,   -1,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,  331,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  313,   -1,  315,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,    0,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,
   -1,   -1,   -1,   -1,    0,  315,   -1,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,    0,  315,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  256,  257,  258,  315,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,   -1,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,   -1,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,  315,    0,
   -1,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,    0,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,
   -1,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,    0,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,    0,  315,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,    0,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,   -1,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  315,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,  315,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,
    0,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
  315,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  315,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,  315,    0,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  315,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  315,   -1,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 391
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"FSC_LIST","FSC_DEFINE",
"FSC_EXEC","FSC_QUIT","FSC_DEBUG","FSC_CREATE","FSC_SLEEP","FSC_STATS",
"FSC_FOREACH","FSC_SET","FSC_SHUTDOWN","FSC_LOG","FSC_SYSTEM","FSC_FLOWOP",
"FSC_EVENTGEN","FSC_ECHO","FSC_LOAD","FSC_RUN","FSC_WARMUP","FSC_NOUSESTATS",
"FSC_FSCHECK","FSC_FSFLUSH","FSC_USAGE","FSC_HELP","FSC_VARS","FSC_VERSION",
"FSC_ENABLE","FSC_DOMULTISYNC","FSV_STRING","FSV_VAL_INT","FSV_VAL_BOOLEAN",
"FSV_VARIABLE","FSV_WHITESTRING","FSV_RANDUNI","FSV_RANDTAB","FSV_RANDVAR",
"FSV_URAND","FSV_RAND48","FST_INT","FST_BOOLEAN","FSE_FILE","FSE_PROC",
"FSE_THREAD","FSE_CLEAR","FSE_ALL","FSE_SNAP","FSE_DUMP","FSE_DIRECTORY",
"FSE_COMMAND","FSE_FILESET","FSE_POSSET","FSE_XMLDUMP","FSE_RAND","FSE_MODE",
"FSE_MULTI","FSE_MULTIDUMP","FSK_SEPLST","FSK_OPENLST","FSK_CLOSELST",
"FSK_ASSIGN","FSK_IN","FSK_QUOTE","FSK_DIRSEPLST","FSK_PLUS","FSK_MINUS",
"FSK_MULTIPLY","FSK_DIVIDE","FSA_SIZE","FSA_PREALLOC","FSA_PARALLOC","FSA_PATH",
"FSA_REUSE","FSA_PROCESS","FSA_MEMSIZE","FSA_RATE","FSA_CACHED","FSA_READONLY",
"FSA_TRUSTTREE","FSA_IOSIZE","FSA_FILE","FSA_POSSET","FSA_WSS","FSA_NAME",
"FSA_RANDOM","FSA_INSTANCES","FSA_DSYNC","FSA_TARGET","FSA_ITERS","FSA_NICE",
"FSA_VALUE","FSA_BLOCKING","FSA_HIGHWATER","FSA_DIRECTIO","FSA_DIRWIDTH",
"FSA_FD","FSA_SRCFD","FSA_ROTATEFD","FSA_NAMELENGTH","FSA_FILESIZE",
"FSA_ENTRIES","FSA_FILESIZEGAMMA","FSA_DIRDEPTHRV","FSA_DIRGAMMA","FSA_USEISM",
"FSA_TYPE","FSA_RANDTABLE","FSA_RANDSRC","FSA_RANDROUND","FSA_LEAFDIRS",
"FSA_INDEXED","FSA_FSTYPE","FSA_RANDSEED","FSA_RANDGAMMA","FSA_RANDMEAN",
"FSA_RANDMIN","FSA_RANDMAX","FSA_MASTER","FSA_CLIENT","FSS_TYPE","FSS_SEED",
"FSS_GAMMA","FSS_MEAN","FSS_MIN","FSS_SRC","FSS_ROUND","FSV_SET_LOCAL_VAR",
"FSA_LVAR_ASSIGN","FSA_ALLDONE","FSA_FIRSTDONE","FSA_TIMEOUT",
"FSC_OSPROF_ENABLE","FSC_OSPROF_DISABLE","FSA_NOREADAHEAD","FSA_IOPRIO",
"FSA_WRITEONLY",
};
char *yyrule[] = {
"$accept : commands",
"commands : commands command",
"commands : commands error",
"commands :",
"inner_commands : command",
"inner_commands : inner_commands command",
"command : proc_define_command",
"command : files_define_command",
"command : posset_define_command",
"command : randvar_define_command",
"command : fo_define_command",
"command : debug_command",
"command : eventgen_command",
"command : create_command",
"command : echo_command",
"command : usage_command",
"command : vars_command",
"command : foreach_command",
"command : fscheck_command",
"command : fsflush_command",
"command : help_command",
"command : list_command",
"command : load_command",
"command : log_command",
"command : run_command",
"command : set_command",
"command : shutdown_command",
"command : sleep_command",
"command : warmup_command",
"command : stats_command",
"command : system_command",
"command : version_command",
"command : osprof_enable_command",
"command : osprof_disable_command",
"command : enable_command",
"command : multisync_command",
"command : quit_command",
"foreach_command : FSC_FOREACH",
"foreach_command : foreach_command FSV_VARIABLE FSK_IN integer_seplist FSK_OPENLST inner_commands FSK_CLOSELST",
"foreach_command : foreach_command FSV_VARIABLE FSK_IN string_seplist FSK_OPENLST inner_commands FSK_CLOSELST",
"integer_seplist : FSV_VAL_INT",
"integer_seplist : integer_seplist FSK_SEPLST FSV_VAL_INT",
"string_seplist : FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"string_seplist : string_seplist FSK_SEPLST FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"eventgen_command : FSC_EVENTGEN",
"eventgen_command : eventgen_command ev_attr_ops",
"system_command : FSC_SYSTEM whitevar_string_list",
"echo_command : FSC_ECHO whitevar_string_list",
"version_command : FSC_VERSION",
"osprof_enable_command : FSC_OSPROF_ENABLE",
"osprof_disable_command : FSC_OSPROF_DISABLE",
"usage_command : FSC_USAGE whitevar_string_list",
"vars_command : FSC_VARS",
"enable_command : FSC_ENABLE FSE_MULTI",
"enable_command : enable_command enable_multi_ops",
"multisync_command : FSC_DOMULTISYNC multisync_op",
"string_list : FSV_VARIABLE",
"string_list : string_list FSK_SEPLST FSV_VARIABLE",
"var_string : FSV_VARIABLE",
"var_string : FSV_STRING",
"var_string_list : var_string",
"var_string_list : var_string FSV_STRING",
"var_string_list : var_string FSV_VARIABLE",
"var_string_list : var_string_list FSV_STRING",
"var_string_list : var_string_list FSV_VARIABLE",
"whitevar_string : FSK_QUOTE FSV_VARIABLE",
"whitevar_string : FSK_QUOTE FSV_WHITESTRING",
"whitevar_string_list : whitevar_string FSV_WHITESTRING",
"whitevar_string_list : whitevar_string FSV_VARIABLE",
"whitevar_string_list : whitevar_string FSV_RANDVAR randvar_attr_tsp",
"whitevar_string_list : whitevar_string_list FSV_WHITESTRING",
"whitevar_string_list : whitevar_string_list FSV_VARIABLE",
"whitevar_string_list : whitevar_string_list FSV_RANDVAR randvar_attr_tsp",
"whitevar_string_list : whitevar_string_list FSK_QUOTE",
"whitevar_string_list : whitevar_string FSK_QUOTE",
"list_command : FSC_LIST",
"list_command : list_command FSC_FLOWOP",
"fscheck_command : FSC_FSCHECK fscheck_attr_op",
"fscheck_command : fscheck_command fscheck_attr_op",
"fsflush_command : FSC_FSFLUSH fscheck_attr_op",
"log_command : FSC_LOG whitevar_string_list",
"debug_command : FSC_DEBUG FSV_VAL_INT",
"set_command : set_integer_command",
"set_command : set_other_command",
"set_integer_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VAL_INT",
"set_integer_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VARIABLE",
"set_integer_command : set_integer_command binary_op FSV_VAL_INT",
"set_integer_command : set_integer_command binary_op FSV_VARIABLE",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VAL_BOOLEAN",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_STRING",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_TIMEOUT",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_ALLDONE",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_FIRSTDONE",
"set_other_command : FSC_SET FSE_MODE FSC_NOUSESTATS",
"set_other_command : FSC_SET FSV_RANDVAR FSS_TYPE FSK_ASSIGN randvar_attr_typop",
"set_other_command : FSC_SET FSV_RANDVAR FSS_SRC FSK_ASSIGN randvar_attr_srcop",
"set_other_command : FSC_SET FSV_RANDVAR randvar_attr_param FSK_ASSIGN attr_value",
"stats_command : FSC_STATS FSE_SNAP",
"stats_command : FSC_STATS FSE_CLEAR",
"stats_command : FSC_STATS FSE_DIRECTORY var_string_list",
"stats_command : FSC_STATS FSE_COMMAND whitevar_string_list",
"stats_command : FSC_STATS FSE_DUMP whitevar_string_list",
"stats_command : FSC_STATS FSE_XMLDUMP whitevar_string_list",
"stats_command : FSC_STATS FSE_MULTIDUMP whitevar_string_list",
"quit_command : FSC_QUIT",
"flowop_list : flowop_command",
"flowop_list : flowop_list flowop_command",
"thread : FSE_THREAD pt_attr_ops FSK_OPENLST flowop_list FSK_CLOSELST",
"thread_list : thread",
"thread_list : thread_list thread",
"proc_define_command : FSC_DEFINE FSE_PROC pt_attr_ops FSK_OPENLST thread_list FSK_CLOSELST",
"proc_define_command : proc_define_command pt_attr_ops",
"files_define_command : FSC_DEFINE FSE_FILE",
"files_define_command : FSC_DEFINE FSE_FILESET",
"files_define_command : files_define_command files_attr_ops",
"posset_define_command : FSC_DEFINE FSE_POSSET",
"posset_define_command : posset_define_command posset_attr_ops",
"randvar_define_command : FSC_DEFINE FSE_RAND randvar_attr_ops",
"fo_define_command : FSC_DEFINE FSC_FLOWOP comp_attr_ops FSK_OPENLST flowop_list FSK_CLOSELST",
"fo_define_command : fo_define_command comp_attr_ops",
"create_command : FSC_CREATE entity",
"shutdown_command : FSC_SHUTDOWN entity",
"warmup_command : FSC_WARMUP FSV_VAL_INT",
"warmup_command : FSC_WARMUP FSV_VARIABLE",
"sleep_command : FSC_SLEEP FSV_VAL_INT",
"sleep_command : FSC_SLEEP FSV_VARIABLE",
"run_command : FSC_RUN FSV_VAL_INT",
"run_command : FSC_RUN FSV_VARIABLE",
"run_command : FSC_RUN",
"help_command : FSC_HELP",
"flowop_command : FSC_FLOWOP name",
"flowop_command : flowop_command fo_attr_ops",
"load_command : FSC_LOAD FSV_STRING",
"entity : FSE_PROC",
"entity : FSE_THREAD",
"entity : FSE_FILESET",
"entity : FSE_FILE",
"value : FSV_VAL_INT",
"value : FSV_STRING",
"value : FSV_VAL_BOOLEAN",
"name : FSV_STRING",
"files_attr_ops : files_attr_op",
"files_attr_ops : files_attr_ops FSK_SEPLST files_attr_op",
"posset_attr_ops : posset_attr_op",
"posset_attr_ops : posset_attr_ops FSK_SEPLST posset_attr_op",
"posset_attr_op : posset_attr_name FSK_ASSIGN attr_list_value",
"posset_attr_op : posset_attr_name",
"files_attr_op : files_attr_name FSK_ASSIGN attr_list_value",
"files_attr_op : files_attr_name",
"randvar_attr_ops : randvar_attr_op",
"randvar_attr_ops : randvar_attr_ops FSK_SEPLST randvar_attr_op",
"randvar_attr_ops : randvar_attr_ops FSK_SEPLST FSA_RANDTABLE FSK_ASSIGN FSK_OPENLST probtabentry_list FSK_CLOSELST",
"randvar_attr_op : randvar_attr_name FSK_ASSIGN attr_list_value",
"randvar_attr_op : randvar_attr_name",
"randvar_attr_op : FSA_TYPE FSK_ASSIGN randvar_attr_typop",
"randvar_attr_op : FSA_RANDSRC FSK_ASSIGN randvar_attr_srcop",
"probtabentry : FSK_OPENLST var_int_val FSK_SEPLST var_int_val FSK_SEPLST var_int_val FSK_CLOSELST",
"probtabentry_list : probtabentry",
"probtabentry_list : probtabentry_list FSK_SEPLST probtabentry",
"pt_attr_ops : pt_attr_op",
"pt_attr_ops : pt_attr_ops FSK_SEPLST pt_attr_op",
"pt_attr_op : pt_attr_name FSK_ASSIGN attr_value",
"pt_attr_op : pt_attr_name",
"fo_attr_ops : fo_attr_op",
"fo_attr_ops : fo_attr_ops FSK_SEPLST fo_attr_op",
"fo_attr_ops : fo_attr_ops FSK_SEPLST comp_lvar_def",
"fo_attr_op : fo_attr_name FSK_ASSIGN attr_value",
"fo_attr_op : fo_attr_name",
"ev_attr_ops : ev_attr_op",
"ev_attr_ops : ev_attr_ops FSK_SEPLST ev_attr_op",
"ev_attr_op : ev_attr_name FSK_ASSIGN attr_value",
"ev_attr_op : ev_attr_name",
"enable_multi_ops : enable_multi_op",
"enable_multi_ops : enable_multi_ops FSK_SEPLST enable_multi_op",
"enable_multi_op : em_attr_name FSK_ASSIGN attr_value",
"multisync_op : FSA_VALUE FSK_ASSIGN attr_value",
"fscheck_attr_op : fscheck_attr_name FSK_ASSIGN FSV_STRING",
"binary_op : FSK_PLUS",
"binary_op : FSK_MINUS",
"binary_op : FSK_MULTIPLY",
"binary_op : FSK_DIVIDE",
"files_attr_name : attrs_define_file",
"files_attr_name : attrs_define_fileset",
"posset_attr_name : attrs_define_posset",
"pt_attr_name : attrs_define_thread",
"pt_attr_name : attrs_define_proc",
"fo_attr_name : attrs_flowop",
"ev_attr_name : attrs_eventgen",
"attrs_define_proc : FSA_NICE",
"attrs_define_proc : FSA_NAME",
"attrs_define_proc : FSA_INSTANCES",
"attrs_define_file : FSA_SIZE",
"attrs_define_file : FSA_NAME",
"attrs_define_file : FSA_PATH",
"attrs_define_file : FSA_READONLY",
"attrs_define_file : FSA_TRUSTTREE",
"attrs_define_file : FSA_REUSE",
"attrs_define_file : FSA_PREALLOC",
"attrs_define_file : FSA_PARALLOC",
"attrs_define_file : FSA_WRITEONLY",
"attrs_define_fileset : FSA_SIZE",
"attrs_define_fileset : FSA_NAME",
"attrs_define_fileset : FSA_PATH",
"attrs_define_fileset : FSA_DIRWIDTH",
"attrs_define_fileset : FSA_DIRDEPTHRV",
"attrs_define_fileset : FSA_PREALLOC",
"attrs_define_fileset : FSA_PARALLOC",
"attrs_define_fileset : FSA_REUSE",
"attrs_define_fileset : FSA_READONLY",
"attrs_define_fileset : FSA_TRUSTTREE",
"attrs_define_fileset : FSA_FILESIZEGAMMA",
"attrs_define_fileset : FSA_DIRGAMMA",
"attrs_define_fileset : FSA_CACHED",
"attrs_define_fileset : FSA_ENTRIES",
"attrs_define_fileset : FSA_LEAFDIRS",
"attrs_define_fileset : FSA_WRITEONLY",
"attrs_define_posset : FSA_NAME",
"attrs_define_posset : FSA_TYPE",
"attrs_define_posset : FSA_RANDSEED",
"attrs_define_posset : FSA_ENTRIES",
"attrs_define_posset : FSA_RANDMAX",
"randvar_attr_name : FSA_NAME",
"randvar_attr_name : FSA_RANDSEED",
"randvar_attr_name : FSA_RANDGAMMA",
"randvar_attr_name : FSA_RANDMEAN",
"randvar_attr_name : FSA_RANDMIN",
"randvar_attr_name : FSA_RANDROUND",
"randvar_attr_tsp : FSS_TYPE",
"randvar_attr_tsp : FSS_SRC",
"randvar_attr_tsp : FSS_SEED",
"randvar_attr_tsp : FSS_GAMMA",
"randvar_attr_tsp : FSS_MEAN",
"randvar_attr_tsp : FSS_MIN",
"randvar_attr_tsp : FSS_ROUND",
"randvar_attr_param : FSS_SEED",
"randvar_attr_param : FSS_GAMMA",
"randvar_attr_param : FSS_MEAN",
"randvar_attr_param : FSS_MIN",
"randvar_attr_param : FSS_ROUND",
"randvar_attr_typop : randtype_name",
"randtype_name : FSV_RANDUNI",
"randtype_name : FSV_RANDTAB",
"randtype_name : FSA_RANDGAMMA",
"randvar_attr_srcop : randsrc_name",
"randsrc_name : FSV_URAND",
"randsrc_name : FSV_RAND48",
"attrs_define_thread : FSA_PROCESS",
"attrs_define_thread : FSA_NAME",
"attrs_define_thread : FSA_MEMSIZE",
"attrs_define_thread : FSA_USEISM",
"attrs_define_thread : FSA_INSTANCES",
"attrs_define_thread : FSA_IOPRIO",
"attrs_flowop : FSA_WSS",
"attrs_flowop : FSA_FILE",
"attrs_flowop : FSA_POSSET",
"attrs_flowop : FSA_NAME",
"attrs_flowop : FSA_RANDOM",
"attrs_flowop : FSA_FD",
"attrs_flowop : FSA_SRCFD",
"attrs_flowop : FSA_ROTATEFD",
"attrs_flowop : FSA_DSYNC",
"attrs_flowop : FSA_DIRECTIO",
"attrs_flowop : FSA_INDEXED",
"attrs_flowop : FSA_TARGET",
"attrs_flowop : FSA_ITERS",
"attrs_flowop : FSA_VALUE",
"attrs_flowop : FSA_BLOCKING",
"attrs_flowop : FSA_HIGHWATER",
"attrs_flowop : FSA_IOSIZE",
"attrs_flowop : FSA_NOREADAHEAD",
"attrs_eventgen : FSA_RATE",
"em_attr_name : FSA_MASTER",
"em_attr_name : FSA_CLIENT",
"fscheck_attr_name : FSA_PATH",
"fscheck_attr_name : FSA_FSTYPE",
"comp_attr_ops : comp_attr_op",
"comp_attr_ops : comp_attr_ops FSK_SEPLST comp_attr_op",
"comp_attr_ops : comp_attr_ops FSK_SEPLST comp_lvar_def",
"comp_attr_op : attrs_define_comp FSK_ASSIGN attr_value",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VAL_BOOLEAN",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VAL_INT",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_STRING",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VARIABLE",
"comp_lvar_def : FSV_VARIABLE",
"attrs_define_comp : FSA_NAME",
"attrs_define_comp : FSA_ITERS",
"attr_value : FSV_STRING",
"attr_value : FSV_VAL_INT",
"attr_value : FSV_VAL_BOOLEAN",
"attr_value : FSV_VARIABLE",
"attr_list_value : var_string_list",
"attr_list_value : FSV_STRING",
"attr_list_value : FSV_VAL_INT",
"attr_list_value : FSV_VAL_BOOLEAN",
"attr_list_value : FSV_VARIABLE",
"var_int_val : FSV_VAL_INT",
"var_int_val : FSV_VARIABLE",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH  500
#endif
#endif

#define YYINITSTACKSIZE 500

int      yydebug;
int      yynerrs;
int      yyerrflag;
int      yychar;
short   *yyssp;
YYSTYPE *yyvsp;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* variables for the parser stack */
static short   *yyss;
static short   *yysslim;
static YYSTYPE *yyvs;
static int      yystacksize;
#line 1842 "parser_gram.y"

/*
 * The following C routines implement the various commands defined in the above
 * yacc parser code. The yacc portion checks the syntax of the commands found in
 * a workload file (or typed interactively) and parses the commands' parameters
 * into lists. The lists are then passed in a cmd_t struct for each command to
 * its related routine in the following section for actual execution.  This
 * section also includes a few utility routines and the main entry point for the
 * program.
 */

#define	USAGE1	\
"Usage:\n" \
"filebench: interprets WML script and generates apporpriate workload\n" \
"Options:\n" \
"   [-h] Display verbose help\n" \
"   [-f <filename>] use specified file as an input instead of stdin\n"

#define	PARSER_CMDS \
"create [files|filesets|processes]\n" \
"stats [clear|snap]\n" \
"stats command \"shell command $var1,$var2...\"\n" \
"stats directory <directory>\n" \
"sleep <sleep-value>\n" \
"quit\n\n" \
"Variables:\n" \
"set $var = value\n" \
"    $var   - regular variables\n" \
"    ${var} - internal special variables\n" \
"    $(var) - environment variables\n\n"

#define	PARSER_EXAMPLE \
"Example:\n\n" \
"#!" FILEBENCHDIR "/bin/filebench -f\n" \
"\n" \
"define file name=bigfile,path=bigfile,size=1g,prealloc,reuse\n" \
"define process name=randomizer\n" \
"{\n" \
"  thread random-thread procname=randomizer\n"	\
"  {\n" \
"    flowop read name=random-read,filename=bigfile,iosize=16k,random\n" \
"  }\n" \
"}\n" \
"create files\n" \
"create processes\n" \
"stats clear\n" \
"sleep 30\n" \
"stats snap\n"

/*
 * Displays brief or verbose help for Filebench.
 */
static void
usage(int help)
{
	if (help >= 1)
		(void) fprintf(stderr, USAGE1);

	if (help >= 2) {
		(void) fprintf(stderr,
		    "\n'f' language definition:\n\n");
		fileset_usage();
		procflow_usage();
		threadflow_usage();
		flowoplib_usage();
		eventgen_usage();
		(void) fprintf(stderr, PARSER_CMDS);
		(void) fprintf(stderr, PARSER_EXAMPLE);
	}

	exit(1);
}

/*
 * mmap() call with MAP_FIXED argument does not guarantee
 * that the allocated memory region is not overlapped with
 * the previously existant mappings. According to POSIX, old mappings
 * are just disregarded. There is no generic way to detect
 * overlap. If overlap occurs strange runtime errors might happen,
 * because we might overlap stack, libraries, anything else.
 *
 * Since we always fork+exec same binary (filebench), theoretically
 * all the mappings should be the same, so no overlap should happen.
 * However, if virtual address space randomization is enabled on the target
 * machine - overlap is very likely (especially if workload defines a lot of
 * processes).  We observed numerous segmentation faults on CentOS because of
 * that.
 *
 * The function below checks if virtual address space randomization is
 * enabled on Linux. In case it is enabled, we print a warning and continue
 * execution.
 */
static void
check_va_randomization()
{
	char buf[4];
	int val;
	int ret;
	int fd;

	fd = open("/proc/sys/kernel/randomize_va_space", O_RDONLY);
	if (fd == -1) {
		/*
		 * probably this file just doesn't exist, so we conclude that the
		 * system does not support virtual address space randomization
		 * and silently return.
		 */
		return;
	}

	ret = read(fd, buf, sizeof(buf));
	if (ret == -1) {
		filebench_log(LOG_FATAL, "Coud not read from "
			"/proc/sys/kernel/randomize_va_space file!");
		return;
	}

	sscanf(buf, "%d", &val);
	if (val != 0) {
		filebench_log(LOG_FATAL, "IMPORTANT: Virtual address space "
			"randomization is enabled on this machine!\n"
			"It is highly recommended to disable randomization "
			"to provide stable Filebench runs.\n"
			"Echo 0 to /proc/sys/kernel/randomize_va_space file "
			"to disable the randomization.");

	}
}

#ifdef HAVE_PROC_SYS_KERNEL_SHMMAX
/*
 * Increase the maximum shared memory segment size till some large value.  We do
 * not restore it to the old value when the Filebench run is over. If we could
 * not change the value - we continue execution.
 */
void
fb_set_shmmax(void)
{
	FILE *f;
	int ret;

	f = fopen("/proc/sys/kernel/shmmax", "r+");
	if (!f) {
		filebench_log(LOG_FATAL, "WARNING: Could not open "
				"/proc/sys/kernel/shmmax file!\n"
				"It means that you probably ran Filebench not "
				"as a root. Filebench will not increase shared\n"
				"region limits in this case, which can lead "
				"to the failures on certain workloads.");
		return; 
	}

	/* writing new value */
#define SOME_LARGE_SHMAX "268435456" /* 256 MB */
	ret = fwrite(SOME_LARGE_SHMAX, sizeof(SOME_LARGE_SHMAX), 1, f);
	if (ret != 1) 
		filebench_log(LOG_ERROR, "Coud not write to "
				"/proc/sys/kernel/shmmax file!");
#undef SOME_LARGE_SHMAX

	return;
}
#else /* HAVE_PROC_SYS_KERNEL_SHMMAX */
void
fb_set_shmmax(void)
{
	return;
}
#endif /* HAVE_PROC_SYS_KERNEL_SHMMAX */

#ifdef HAVE_SETRLIMIT
/*
 * Increase the limit of opened files.
 *
 * We first set the limit to the hardlimit reported by the kernel; this call
 * will always succeed.  Then we try to set the limit to some large number of
 * files (unfortunately we can't set this ulimit to infinity), this will only
 * succeed if the process is ran by root.  Therefore, we always set the maximum
 * possible value for the limit for this given process (well, only if hardlimit
 * is greater then the large number of files defined by us, it is not true).
 *
 * Increasing this limit is especially important when we use thread model,
 * because opened files are accounted per-process, not per-thread.
 */
void
fb_set_rlimit(void)
{
	struct rlimit rlp;

	(void)getrlimit(RLIMIT_NOFILE, &rlp);
	rlp.rlim_cur = rlp.rlim_max;
	(void)setrlimit(RLIMIT_NOFILE, &rlp);
#define SOME_LARGE_NUMBER_OF_FILES 50000
	rlp.rlim_cur = rlp.rlim_max = SOME_LARGE_NUMBER_OF_FILES;
#undef SOME_LARGE_NUMBER_OF_FILES
	(void)setrlimit(RLIMIT_NOFILE, &rlp);
	return;
}
#else /* HAVE_SETRLIMIT */
void
fb_set_rlimit(void)
{
	return;
}
#endif /* HAVE_SETRLIMIT */

/*
 * Entry point for Filebench. Processes command line arguments. The -f option
 * will read in a workload file (the full name and extension must must be
 * given). The -a, -s, -m and -i options are used by the worker process to
 * receive the name, the base address of shared memory, its path, and the
 * process' instance number, respectively. This information is supplied by the
 * master process when it execs worker processes. If the worker process
 * arguments are passed then main will call the procflow_exec() routine which
 * creates worker threadflows and flowops and executes the procflow's portion of
 * the workload model until completion. If worker process arguments are not
 * passed to the process, then it becomes the master process for a filebench
 * run. It initializes the various filebench components and either executes the
 * supplied workload file, or enters interactive mode.
 */
int
main(int argc, char *argv[])
{
	const char cmd_options[] = "m:s:a:i:hf:";
	int opt;
	char *procname = NULL;
	int instance;
	void *shmaddr;
	char *cwdret;
	char *fscriptname = NULL;
#ifdef HAVE_LIBTECLA
	char *line;
#else /* HAVE_LIBTECLA */
	char line[1024];
#endif

	 /* parsing the parameters */
	while ((opt = getopt(argc, argv, cmd_options)) > 0) {
		switch (opt) {
		/* public parameters */
		case 'h':
			usage(2);
			break;
		case 'f':
			if (!optarg)
				usage(1);

			yyin = fopen(optarg, "r");
			if (!yyin) {
				filebench_log(LOG_FATAL,
				    "Cannot open file %s!", optarg);
				exit(1);
			}

			dofile = DOFILE_TRUE;
			fscriptname = optarg;
			break;
		/* private parameters: when filebench calls itself */
		case 'a':
			if (!optarg)
				usage(1);

			procname = optarg;
			break;
		case 's':
			if (!optarg)
				usage(1);
			sscanf(optarg, "%p", &shmaddr);
			break;
		case 'm':
			if (!optarg)
				usage(1);
			sscanf(optarg, "%s", shmpath);
			break;
		case 'i':
			if (!optarg)
				usage(1);
			sscanf(optarg, "%d", &instance);
			break;
		case '?':
		default:
			usage(1);
			break;
		}
	}

	/*
	 * Init things common to all processes: master and workers
	 */
	my_pid = getpid();
	fb_set_rlimit();
	fb_urandom_init();
	clock_init();

	if (procname) {
		/* A child Filebench instance */
		if (ipc_attach(shmaddr) < 0) {
			filebench_log(LOG_FATAL, "Cannot attach shm for %s",
			    procname);
			exit(1);
		}

		/* get correct function pointer for each working process */
		filebench_plugin_funcvecinit();

		/* execute corresponding procflow */
		if (procflow_exec(procname, instance) < 0) {
			filebench_log(LOG_FATAL, "Cannot startup process %s",
			    procname);
			exit(1);
		}

		exit(0);
	}

	/*
	 * Master process
	 */
	printf("Filebench Version %s\n", FILEBENCH_VERSION);
	check_va_randomization();

	/* saving executable name to exec it later as worker processes */
	execname = argv[0];

	/* saving current working directory */
	cwdret = getcwd(cwd, MAXPATHLEN);
	if (cwdret != cwd) {
		filebench_log(LOG_FATAL, "Cannot save current "
					 "working directory!");
		exit(1);
	}

	fb_set_shmmax();

	ipc_init();

	if (fscriptname)
		(void)strcpy(filebench_shm->shm_fscriptname, fscriptname);

	flowop_init();
	stats_init();
	eventgen_init();

	signal(SIGINT, parser_abort);

	if (dofile == DOFILE_TRUE)
		yyparse();
	else {
#ifdef HAVE_LIBTECLA
		if ((gl = new_GetLine(MAX_LINE_LEN, MAX_CMD_HIST)) == NULL) {
			filebench_log(LOG_ERROR,
			    "Failed to create GetLine object");
			filebench_shutdown(1);
		}

		if (gl_customize_completion(gl, NULL, command_complete)) {
			filebench_log(LOG_ERROR,
			    "Failed to register auto-completion function");
			filebench_shutdown(1);
		}

		while ((line = gl_get_line(gl, FILEBENCH_PROMPT, NULL, -1))) {
			arg_parse(line);
			yyparse();
		}

		del_GetLine(gl);
#else
		while (!feof(stdin)) {
			printf(FILEBENCH_PROMPT);
			fflush(stdout);
			if (fgets(line, sizeof (line), stdin) == NULL) {
				if (errno == EINTR)
					continue;
				else
					break;
			}
			arg_parse(line);
			yyparse();
		}
		printf("\n");
#endif	/* HAVE_LIBTECLA */
	}

	parser_filebench_shutdown((cmd_t *)0);

	return 0;
}

/*
 * arg_parse() puts the parser into command parsing mode. Create a tmpfile
 * and instruct the parser to read instructions from this location by setting
 * yyin to the value returned by tmpfile. Write the command into the file.
 * Then seek back to to the start of the file so that the parser can read
 * the instructions.
 */
static void
arg_parse(const char *command)
{
	if ((yyin = tmpfile()) == NULL) {
		filebench_log(LOG_FATAL,
		    "Exiting: Cannot create tmpfile: %s", strerror(errno));
		exit(1);
	}

	if (fwrite(command, strlen(command), 1, yyin) != 1)
		filebench_log(LOG_FATAL,
		    "Cannot write tmpfile: %s", strerror(errno));

	if (fseek(yyin, 0, SEEK_SET) != 0)
		filebench_log(LOG_FATAL,
		    "Cannot seek tmpfile: %s", strerror(errno));
}

/*
 * Converts a list of var_strings or ordinary strings to a single ordinary
 * string. It returns a pointer to the string (in malloc'd memory) if found,
 * or NULL otherwise.
 */
char *
parser_list2string(list_t *list)
{
	list_t *l;
	char *string;
	char *tmp;
	if ((string = malloc(MAXPATHLEN)) == NULL) {
		filebench_log(LOG_ERROR, "Failed to allocate memory");
		return (NULL);
	}

	*string = 0;

	/*	printf("parser_list2string: called\n"); */
	/* Format args */
	for (l = list; l != NULL; l = l->list_next) {
		char *lstr = avd_get_str(l->list_string);

		filebench_log(LOG_DEBUG_SCRIPT,
		    "converting string '%s'", lstr);

		/* see if it is a random variable */
		if (l->list_integer) {
			fbint_t param_name;

			tmp = NULL;
			param_name = avd_get_int(l->list_integer);
			switch (param_name) {
			case FSS_TYPE:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_TYPE);
				break;

			case FSS_SRC:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_SRC);
				break;

			case FSS_SEED:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_SEED);
				break;

			case FSS_MIN:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_MIN);
				break;

			case FSS_MEAN:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_MEAN);
				break;

			case FSS_GAMMA:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_GAMMA);
				break;

			case FSS_ROUND:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_ROUND);
				break;
			}

			if (tmp) {
				(void) strcat(string, tmp);
				free(tmp);
			} else {
				(void) strcat(string, lstr);
			}
		} else {
			/* perhaps a normal variable? */
			if ((tmp = var_to_string(lstr)) != NULL) {
				(void) strcat(string, tmp);
				free(tmp);
			} else {
				(void) strcat(string, lstr);
			}
		}
	}
	return (string);
}

/*
 * If the list just contains a single string starting with '$', then find
 * or create the named var and return the var's var_string component.
 * Otherwise, convert the list to a string, and allocate a var_string
 * containing a copy of that string. On failure either returns NULL
 * or shuts down the run.
 */
avd_t
parser_list2varstring(list_t *list)
{
	char *lstr = avd_get_str(list->list_string);

	/*	printf("parser_list2varstring: Called\n"); */
	/* Special case - variable name */
	if ((list->list_next == NULL) && (*lstr == '$'))
		return (var_ref_attr(lstr));

	return (avd_str_alloc(parser_list2string(list)));
}

/*
 * Looks for the var named in list_string of the first element of the
 * supplied list. If found, returns the var_val portion of the var in
 * an attribute value descriptor. If the var is not found, cannot be
 * allocated, the supplied list is NULL, or the list_string filed is
 * empty, returns NULL.
 */
avd_t
parser_list2avd(list_t *list)
{
	avd_t avd;
	char *lstr;

	if (list && ((lstr = avd_get_str(list->list_string)) != NULL)) {
		avd = var_ref_attr(lstr);
		return (avd);
	}

	return (NULL);
}

/*
 * Sets the event generator rate from the attribute supplied with the
 * command. If the attribute doesn't exist the routine does nothing.
 */
static void
parser_eventgen(cmd_t *cmd)
{
	attr_t *attr;

	/* Get the rate from attribute */
	if ((attr = get_attr_integer(cmd, FSA_RATE))) {
		if (attr->attr_avd) {
			eventgen_setrate(attr->attr_avd);
		}
	}
}

/*
 * Assigns the designated integer variable successive values from the
 * supplied comma seperated integer list. After each successive integer
 * assignment, it executes the bracket enclosed list of commands. For
 * example, repeated runs of a workload with increasing io sizes can
 * be done using the following command line:
 * 	foreach $iosize in 2k, 4k, 8k {run 60}
 */
static void
parser_foreach_integer(cmd_t *cmd)
{
	list_t *list = cmd->cmd_param_list;
	cmd_t *inner_cmd;

	for (; list != NULL; list = list->list_next) {
		fbint_t list_int = avd_get_int(list->list_integer);

		var_assign_integer(cmd->cmd_tgt1, list_int);
		filebench_log(LOG_VERBOSE, "Iterating %s=%llu",
		    cmd->cmd_tgt1, (u_longlong_t)list_int);
		for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			inner_cmd->cmd(inner_cmd);
		}
	}
}

/*
 * Similar to parser_foreach_integer(), except takes a list of strings after
 * the "in" token. For example, to run twice using a different directory,
 * perhaps using a different filesystem, the following command line
 * could be used:
 * 	foreach $dir in "/ufs_top/fbt", "/zfs_top/fbt" {run 60)
 */
static void
parser_foreach_string(cmd_t *cmd)
{
	list_t *list = cmd->cmd_param_list;

	for (; list != NULL; list = list->list_next) {
		cmd_t *inner_cmd;
		char *lstr = avd_get_str(list->list_string);
		var_assign_string(cmd->cmd_tgt1, lstr);
		filebench_log(LOG_VERBOSE, "Iterating %s=%s",
		    cmd->cmd_tgt1, lstr);
		for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			inner_cmd->cmd(inner_cmd);
		}
	}
}

/*
 * Lists the fileset name, path name and average size for all defined
 * filesets.
 */
static void
parser_list(cmd_t *cmd)
{
	(void) fileset_iter(fileset_print);
}

/*
 * Lists the flowop name and instance number for all flowops.
 */
static void
parser_flowop_list(cmd_t *cmd)
{
	flowop_printall();
}

/*
 * Calls procflow_define() to allocate "instances" number of  procflow(s)
 * (processes) with the supplied name. The default number of instances is
 * one. An optional priority level attribute can be supplied and is stored in
 * pf_nice. Finally the routine loops through the list of inner commands, if
 * any, which are defines for threadflows, and passes them one at a time to
 * parser_thread_define() to allocate threadflow entities for the process(es).
 */
static void
parser_proc_define(cmd_t *cmd)
{
	procflow_t *procflow;
	char *name = NULL;
	attr_t *attr;
	avd_t var_instances;
	fbint_t instances;
	cmd_t *inner_cmd;

	/* Get the name of the process */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define proc: proc specifies no name");
		filebench_shutdown(1);
	}

	/* Get the memory size from attribute */
	if ((attr = get_attr_integer(cmd, FSA_INSTANCES))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "proc_define: Instances attr cannot be random");
			filebench_shutdown(1);
		}
		var_instances = attr->attr_avd;
		instances = avd_get_int(var_instances);
		filebench_log(LOG_DEBUG_IMPL,
		    "Setting instances = %llu", (u_longlong_t)instances);
	} else {
		filebench_log(LOG_DEBUG_IMPL,
		    "Defaulting to instances = 1");
		var_instances = avd_int_alloc(1);
		instances = 1;
	}

	if ((procflow = procflow_define(name, NULL, var_instances)) == NULL) {
		filebench_log(LOG_ERROR,
		    "Failed to instantiate %d %s process(es)\n",
		    instances, name);
		filebench_shutdown(1);
	}

	/* Get the pri from attribute */
	if ((attr = get_attr_integer(cmd, FSA_NICE))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "proc_define: priority cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL, "Setting pri = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		procflow->pf_nice = attr->attr_avd;
	} else
		procflow->pf_nice = avd_int_alloc(0);


	/* Create the list of threads for this process  */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_thread_define(inner_cmd, procflow, instances);
	}
}

/*
 * Calls threadflow_define() to allocate "instances" number of  threadflow(s)
 * (threads) with the supplied name. The default number of instances is
 * one. Two other optional attributes may be supplied, one to set the memory
 * size, stored in tf_memsize, and to select the use of Interprocess Shared
 * Memory, which sets the THREADFLOW_USEISM flag in tf_attrs. Finally
 * the routine loops through the list of inner commands, if any, which are
 * defines for flowops, and passes them one at a time to
 * parser_flowop_define() to allocate flowop entities for the threadflows.
 */
static void
parser_thread_define(cmd_t *cmd, procflow_t *procflow, int procinstances)
{
	threadflow_t *threadflow, template;
	attr_t *attr;
	avd_t instances;
	cmd_t *inner_cmd;
	char *name = NULL;

	memset(&template, 0, sizeof (threadflow_t));

	/* Get the name of the thread */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define thread: thread in process %s specifies no name",
		    procflow->pf_name);
		filebench_shutdown(1);
	}

	/* Get the number of instances from attribute */
	if ((attr = get_attr_integer(cmd, FSA_INSTANCES))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: Instances attr cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting instances = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		instances = attr->attr_avd;
	} else
		instances = avd_int_alloc(1);

	/* Get the memory size from attribute */
	if ((attr = get_attr_integer(cmd, FSA_MEMSIZE))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: Memory size cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting memsize = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		template.tf_memsize = attr->attr_avd;
	} else
		template.tf_memsize = avd_int_alloc(0);

	/* Get ioprio parameters from attribute */
	if ((attr = get_attr_integer(cmd, FSA_IOPRIO))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: ioprio cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting ioprio = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		template.tf_ioprio = attr->attr_avd;
	} else
		template.tf_ioprio = avd_int_alloc(8);

	if ((threadflow = threadflow_define(procflow, name,
	    &template, instances)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define thread: Failed to instantiate thread\n");
		filebench_shutdown(1);
	}

	/* Use ISM Memory? */
	if ((attr = get_attr(cmd, FSA_USEISM))) {
		threadflow->tf_attrs |= THREADFLOW_USEISM;
	}

	/* Create the list of flowops */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_flowop_define(inner_cmd, threadflow,
		    &threadflow->tf_thrd_fops, FLOW_MASTER);
	}
}

/*
 * Fills in the attributes for a newly allocated flowop
 */
static void
parser_flowop_get_attrs(cmd_t *cmd, flowop_t *flowop)
{
	attr_t *attr;

	/* Get the filename from attribute */
	if ((attr = get_attr(cmd, FSA_FILE))) {
		flowop->fo_filename = attr->attr_avd;
		if (flowop->fo_filename == NULL) {
			filebench_log(LOG_ERROR,
			    "define flowop: no filename specfied");
			filebench_shutdown(1);
		}
	} else {
		/* no filename attribute specified */
		flowop->fo_filename = NULL;
	}

	/* Get the possetname from attribute */
	if ((attr = get_attr(cmd, FSA_POSSET))) {
		flowop->fo_possetname = attr->attr_avd;
		if (flowop->fo_possetname == NULL) {
			filebench_log(LOG_ERROR,
			    "parser_flowop_get_attrs: no "
				"posset name specfied");
			filebench_shutdown(1);
		}
	} else {
		/* no possetname attribute specified */
		flowop->fo_possetname = NULL;
	}

	/* Get the iosize of the op */
	if ((attr = get_attr_integer(cmd, FSA_IOSIZE)))
		flowop->fo_iosize = attr->attr_avd;
	else
		flowop->fo_iosize = avd_int_alloc(0);

	/* Get the working set size of the op */
	if ((attr = get_attr_integer(cmd, FSA_WSS)))
		flowop->fo_wss = attr->attr_avd;
	else
		flowop->fo_wss = avd_int_alloc(0);

	/* Random I/O? */
	if ((attr = get_attr_bool(cmd, FSA_RANDOM)))
		flowop->fo_random = attr->attr_avd;
	else
		flowop->fo_random = avd_bool_alloc(FALSE);

	/* Sync I/O? */
	if ((attr = get_attr_bool(cmd, FSA_DSYNC)))
		flowop->fo_dsync = attr->attr_avd;
	else
		flowop->fo_dsync = avd_bool_alloc(FALSE);

	/* Target, for wakeup etc */
	if ((attr = get_attr(cmd, FSA_TARGET)))
		(void) strcpy(flowop->fo_targetname,
		    avd_get_str(attr->attr_avd));

	/* Value */
	if ((attr = get_attr_integer(cmd, FSA_VALUE)))
		flowop->fo_value = attr->attr_avd;
	else
		flowop->fo_value = avd_int_alloc(0);

	/* FD */
	if ((attr = get_attr_integer(cmd, FSA_FD))) {
		flowop->fo_fdnumber = avd_get_int(attr->attr_avd);
		if (flowop->fo_filename != NULL)
			filebench_log(LOG_DEBUG_SCRIPT, "It is not "
			    "advisable to supply both an fd number "
			    "and a fileset name in most cases");
	}

	/* Rotatefd? */
	if ((attr = get_attr_bool(cmd, FSA_ROTATEFD)))
		flowop->fo_rotatefd = attr->attr_avd;
	else
		flowop->fo_rotatefd = avd_bool_alloc(FALSE);

	/* SRC FD, for copies etc... */
	if ((attr = get_attr_integer(cmd, FSA_SRCFD)))
		flowop->fo_srcfdnumber = avd_get_int(attr->attr_avd);

	/* Blocking operation? */
	if ((attr = get_attr_bool(cmd, FSA_BLOCKING)))
		flowop->fo_blocking = attr->attr_avd;
	else
		flowop->fo_blocking = avd_bool_alloc(FALSE);

	/* Direct I/O Operation */
	if ((attr = get_attr_bool(cmd, FSA_DIRECTIO)))
		flowop->fo_directio = attr->attr_avd;
	else
		flowop->fo_directio = avd_bool_alloc(FALSE);

	/* Highwater mark */
	if ((attr = get_attr_integer(cmd, FSA_HIGHWATER))) {
		flowop->fo_highwater = attr->attr_avd;
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define flowop: Highwater attr cannot be random");
			filebench_shutdown(1);
		}
	} else {
		flowop->fo_highwater = avd_int_alloc(1);
	}

	/* find file or leaf directory by index number */
	if ((attr = get_attr_integer(cmd, FSA_INDEXED)))
		flowop->fo_fileindex = attr->attr_avd;
	else
		flowop->fo_fileindex = NULL;

	/* Read Ahead Diable */
	if ((attr = get_attr_bool(cmd, FSA_NOREADAHEAD)))
		flowop->fo_noreadahead = attr->attr_avd;
	else
		flowop->fo_noreadahead = avd_bool_alloc(FALSE);


}

/*
 * defines the FLOW_MASTER flowops within a FLOW_MASTER instance of
 * a composit flowop. Default attributes from the FLOW_INNER_DEF instances
 * of the composit flowop's inner flowops are used if set. Otherwise
 * default attributes from the FLOW_MASTER instance of the composit flowop
 * are used, which may include defaults from the original FLOW_DEFINITION
 * of the composit flowop.
 */
static void
parser_inner_flowop_define(threadflow_t *thread, flowop_t *comp0_flow,
			   flowop_t *comp_mstr_flow)
{
	flowop_t *inner_flowtype, *inner_flowop;

	/* follow flowop list, creating composit names */
	inner_flowtype = comp0_flow->fo_comp_fops;
	comp_mstr_flow->fo_comp_fops = NULL;

	while (inner_flowtype) {
		char fullname[MAXPATHLEN];

		/* create composite_name.name for new flowop */
		snprintf(fullname, MAXPATHLEN, "%s.%s",
		    comp_mstr_flow->fo_name, inner_flowtype->fo_name);

		if ((inner_flowop = flowop_define(thread, fullname,
		    inner_flowtype, &comp_mstr_flow->fo_comp_fops,
		    FLOW_MASTER, 0)) == NULL) {
			filebench_log(LOG_ERROR,
			    "define flowop: Failed to instantiate flowop %s\n",
			    fullname);
			filebench_shutdown(1);
		}

		/* if applicable, update filename attribute */
		if (inner_flowop->fo_filename) {
			char *name;

			/* fix up avd_t */
			avd_update(&inner_flowop->fo_filename,
			    comp_mstr_flow->fo_lvar_list);

			/* see if ready to get the file or fileset */
			name = avd_get_str(inner_flowop->fo_filename);
			if (name) {

				inner_flowop->fo_fileset = fileset_find(name);

				if (inner_flowop->fo_fileset == NULL) {
					filebench_log(LOG_ERROR,
					    "inr flowop %s: file %s not found",
					    inner_flowop->fo_name, name);
					filebench_shutdown(1);
				}
			}
		}

		/* update attributes from local variables */
		avd_update(&inner_flowop->fo_iters,
		    comp_mstr_flow->fo_lvar_list);

		/* if the inner flowop is a composit flowop, recurse */
		if (inner_flowtype->fo_type == FLOW_TYPE_COMPOSITE) {
			var_t *newlvar, *proto_lvars, *lvar_ptr;

			proto_lvars = inner_flowop->fo_lvar_list;
			inner_flowop->fo_lvar_list = 0;

			for (lvar_ptr = inner_flowtype->fo_lvar_list; lvar_ptr;
			    lvar_ptr = lvar_ptr->var_next) {

				if ((newlvar = var_lvar_alloc_local(
				    lvar_ptr->var_name)) != NULL) {

					add_lvar_to_list(newlvar,
					    &inner_flowop->fo_lvar_list);

					var_update_comp_lvars(newlvar,
					    proto_lvars,
					    comp_mstr_flow->fo_lvar_list);
				}
			}
		  
			parser_inner_flowop_define(thread,
			    inner_flowtype,
			    inner_flowop);

			inner_flowtype = inner_flowtype->fo_exec_next;
			continue;
		}

		avd_update(&inner_flowop->fo_iosize,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_wss,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_iters,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_value,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_random,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_dsync,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_rotatefd,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_blocking,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_directio,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_highwater,
		    comp_mstr_flow->fo_lvar_list);

		inner_flowtype = inner_flowtype->fo_exec_next;
	}
}

/*
 * Calls flowop_define() to allocate a flowop with the supplied name.
 * The allocated flowop inherits attributes from a base flowop of the
 * same type.  If the new flowop has a file or fileset attribute specified,
 * it must specify a defined fileobj or fileset or an error will be logged.
 * The new flowop may  also have the following attributes set by
 * the program:
 *  - file size (fo_iosize)
 *  - working set size (fo_wss)
 *  - do random io (fo_random)
 *  - do synchronous io (fo_dsync)
 *  - perform each operation multiple times before advancing (fo_iter)
 *  - target name (fo_targetname)
 *  - An integer value (fo_value)
 *  - a file descriptor (fo_fd)
 *  - specify to rotate file descriptors (fo_rotatefd)
 *  - a source fd (fo_srcfdnumber)
 *  - specify a blocking operation (fo_blocking)
 *  - specify a highwater mark (fo_highwater)
 *
 * After all the supplied attributes are stored in their respective locations
 * in the flowop object, the flowop's init function is called. No errors are
 * returned, but the filebench run will be terminated if the flowtype is not
 * specified, a name for the new flowop is not supplied, the flowop_define
 * call fails, or a file or fileset name is supplied but the corresponding
 * fileobj or fileset cannot be located.
 */
static void
parser_flowop_define(cmd_t *cmd, threadflow_t *thread,
    flowop_t **flowoplist_hdp, int category)
{
	flowop_t *flowop, *flowop_type;
	char *type = (char *)cmd->cmd_name;
	char *name = NULL;
	attr_t *attr;

	/* Get the inherited flowop */
	flowop_type = flowop_find(type);
	if (flowop_type == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: flowop type %s not found",
		    type);
		filebench_shutdown(1);
	}

	/* Get the name of the flowop */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define flowop: flowop %s specifies no name",
		    flowop_type->fo_name);
		filebench_shutdown(1);
	}

	if ((flowop = flowop_define(thread, name,
	    flowop_type, flowoplist_hdp, category, 0)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: Failed to instantiate flowop %s\n",
		    cmd->cmd_name);
		filebench_shutdown(1);
	}

	/* Iterations */
	if ((attr = get_attr_integer(cmd, FSA_ITERS)))
		flowop->fo_iters = attr->attr_avd;
	else
		flowop->fo_iters = avd_int_alloc(1);


	/* if this is a use of a composit flowop, create inner FLOW MASTERS */
	if (flowop_type->fo_type == FLOW_TYPE_COMPOSITE) {
		get_attr_lvars(cmd, flowop);
		if (category == FLOW_MASTER)
			parser_inner_flowop_define(thread,
			    flowop_type, flowop);
	}
	else {
		parser_flowop_get_attrs(cmd, flowop);
	}
}

static void
parser_composite_flowop_define(cmd_t *cmd)
{
	flowop_t *flowop;
	cmd_t *inner_cmd;
	char *name = NULL;
	attr_t *attr;

	/* Get the name of the flowop */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define flowop: Composit flowop specifies no name");

		filebench_shutdown(1);
	}

	if ((flowop = flowop_new_composite_define(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: Failed to instantiate flowop %s\n",
		    cmd->cmd_name);
		filebench_shutdown(1);
	}

	/* place any local var_t variables on the flowop's local list */
	get_attr_lvars(cmd, flowop);

	/* Iterations */
	if ((attr = get_attr_integer(cmd, FSA_ITERS)))
		flowop->fo_iters = attr->attr_avd;
	else
		flowop->fo_iters = avd_int_alloc(1);

	/* define inner flowops */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_flowop_define(inner_cmd, NULL,
		    &flowop->fo_comp_fops, FLOW_INNER_DEF);
	}
}


/*
 * Calls fileset_define() to allocate a fileset with the supplied name and
 * initializes the fileset's pathname attribute, and optionally the
 * fileset_cached, fileset_reuse, fileset_prealloc and fileset_size attributes.
 *
 */
static fileset_t *
parser_fileset_define_common(cmd_t *cmd)
{
	fileset_t *fileset;
	avd_t name;
	attr_t *attr;
	avd_t pathname;

	/*
	 * Make sure all plugin flowops are initialized.
	 * Defaults to local fs for now
	 */
	flowop_plugin_flowinit();

	/* Get the name of the file */
	if ((attr = get_attr_fileset(cmd, FSA_NAME))) {
		name = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		    "define fileset: file or fileset specifies no name");
		return (NULL);
	}

	if ((fileset = fileset_define(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define file: failed to instantiate file %s\n",
		    avd_get_str(name));
		return (NULL);
	}

	/* Get the pathname from attribute */
	if ((attr = get_attr(cmd, FSA_PATH)) == NULL) {
		filebench_log(LOG_ERROR, "define file: no pathname specified");
		return (NULL);
	}

	/* Expand variables in pathname */
	if ((pathname = parser_list2varstring(attr->attr_param_list))
	    == NULL) {
		filebench_log(LOG_ERROR, "Cannot interpret path");
		return (NULL);
	}

	fileset->fs_path = pathname;

	/* How much should we preallocate? */
	if ((attr = get_attr_integer(cmd, FSA_PREALLOC)) &&
	    attr->attr_avd) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define fileset: Prealloc attr cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_preallocpercent = attr->attr_avd;
	} else if (attr && !attr->attr_avd) {
		fileset->fs_preallocpercent = avd_int_alloc(100);
	} else {
		fileset->fs_preallocpercent = avd_int_alloc(0);
	}

	/* Should we preallocate? */
	if ((attr = get_attr_bool(cmd, FSA_PREALLOC)))
		fileset->fs_prealloc = attr->attr_avd;
	else
		fileset->fs_prealloc = avd_bool_alloc(FALSE);

	/* Should we prealloc in parallel? */
	if ((attr = get_attr_bool(cmd, FSA_PARALLOC)))
		fileset->fs_paralloc = attr->attr_avd;
	else
		fileset->fs_paralloc = avd_bool_alloc(FALSE);

	/* Should we allow writes to the file? */
	if ((attr = get_attr_bool(cmd, FSA_READONLY)))
		fileset->fs_readonly = attr->attr_avd;
	else
		fileset->fs_readonly = avd_bool_alloc(FALSE);

	if ((attr = get_attr_bool(cmd, FSA_WRITEONLY)))
		fileset->fs_writeonly = attr->attr_avd;
	else
		fileset->fs_writeonly = avd_bool_alloc(FALSE);

	if ((avd_get_bool(fileset->fs_readonly) == TRUE) &&
		(avd_get_bool(fileset->fs_writeonly) == TRUE)) {
		filebench_log(LOG_ERROR, "fileset can't be read-only and "
					"write-only at the same time!");
		return NULL;
	}

	/* Should we reuse the existing file? */
	if ((attr = get_attr_bool(cmd, FSA_REUSE)))
		fileset->fs_reuse = attr->attr_avd;
	else
		fileset->fs_reuse = avd_bool_alloc(FALSE);

	/* Should we check for files actual existance? */
	if ((attr = get_attr_bool(cmd, FSA_TRUSTTREE)))
		fileset->fs_trust_tree = attr->attr_avd;
	else
		fileset->fs_trust_tree = avd_bool_alloc(FALSE);

	/* Should we leave in cache? */
	if ((attr = get_attr_bool(cmd, FSA_CACHED)))
		fileset->fs_cached = attr->attr_avd;
	else
		fileset->fs_cached = avd_bool_alloc(FALSE);

	/* Get the mean or absolute size of the file */
	if ((attr = get_attr_integer(cmd, FSA_SIZE)))
		fileset->fs_size = attr->attr_avd;
	else
		fileset->fs_size = avd_int_alloc(0);

	return (fileset);
}

/*
 * Calls parser_fileset_define_common() to allocate a fileset with
 * one entry and optionally the fileset_prealloc. sets the fileset_entries,
 * fileset_dirwidth, fileset_dirgamma, and fileset_sizegamma attributes
 * to appropriate values for emulating the old "fileobj" entity
 */
static void
parser_file_define(cmd_t *cmd)
{
	fileset_t *fileset;

	if ((fileset = parser_fileset_define_common(cmd)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define file: failed to instantiate file");
		filebench_shutdown(1);
		return;
	}

	/* fileset is emulating a single file */
	fileset->fs_attrs = FILESET_IS_FILE;

	/* Set the size of the fileset to 1 */
	fileset->fs_entries = avd_int_alloc(1);

	/* Set the mean dir width to more than 1 */
	fileset->fs_dirwidth = avd_int_alloc(10);

	/* Set the dir and size gammas to 0 */
	fileset->fs_dirgamma = avd_int_alloc(0);
	fileset->fs_sizegamma = avd_int_alloc(0);
}

/*
 * Calls parser_fileset_define_common() to allocate a fileset with the
 * supplied name and initializes the fileset's fileset_preallocpercent,
 * fileset_prealloc, fileset_entries, fileset_dirwidth, fileset_dirgamma,
 * and fileset_sizegamma attributes.
 */
static void
parser_fileset_define(cmd_t *cmd)
{
	fileset_t *fileset;
	attr_t *attr;

	if ((fileset = parser_fileset_define_common(cmd)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define fileset: failed to instantiate fileset");
		filebench_shutdown(1);
		return;
	}
	/* Get the number of files in the fileset */
	if ((attr = get_attr_integer(cmd, FSA_ENTRIES))) {
		fileset->fs_entries = attr->attr_avd;
	} else {
		fileset->fs_entries = avd_int_alloc(0);
	}

	/* Get the number of leafdirs in the fileset */
	if ((attr = get_attr_integer(cmd, FSA_LEAFDIRS))) {
		fileset->fs_leafdirs = attr->attr_avd;
	} else {
		fileset->fs_leafdirs = avd_int_alloc(0);
	}

	if ((avd_get_int(fileset->fs_entries) == 0) &&
	    (avd_get_int(fileset->fs_leafdirs) == 0)) {
		filebench_log(LOG_ERROR, "Fileset has no files or leafdirs");
	}

	/* Get the mean dir width of the fileset */
	if ((attr = get_attr_integer(cmd, FSA_DIRWIDTH))) {
		fileset->fs_dirwidth = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR, "Fileset has zero directory width");
		fileset->fs_dirwidth = avd_int_alloc(0);
	}

	/* Get the random variable for dir depth, if supplied */
	if ((attr = get_attr_integer(cmd, FSA_DIRDEPTHRV))) {
		if (!AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: dirdepthrv must be random var");
			filebench_shutdown(1);
		}
		fileset->fs_dirdepthrv = attr->attr_avd;
	} else {
		fileset->fs_dirdepthrv = NULL;
	}

	/* Get the gamma value for dir depth distributions */
	if ((attr = get_attr_integer(cmd, FSA_DIRGAMMA))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: dirgamma attr cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_dirgamma = attr->attr_avd;
	} else
		fileset->fs_dirgamma = avd_int_alloc(1500);

	/* Get the gamma value for dir width distributions */
	if ((attr = get_attr_integer(cmd, FSA_FILESIZEGAMMA))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: filesizegamma cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_sizegamma = attr->attr_avd;
	} else
		fileset->fs_sizegamma = avd_int_alloc(1500);
}

static void
parser_posset_define(cmd_t *cmd)
{
	attr_t *attr;
	avd_t name;
	avd_t type;
	avd_t seed;
	avd_t max;
	avd_t entries;
	int i;

	struct posset *ps;
	
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no name specified for the posset");
		filebench_shutdown(1);
		return;
	}

	if ((attr = get_attr(cmd, FSA_TYPE))) {
		type = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no type specified for the posset");
		filebench_shutdown(1);
		return;
	}

	if ((attr = get_attr_integer(cmd, FSA_ENTRIES))) {
		entries = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no entries number "
					"specified for the posset");
		filebench_shutdown(1);
		return;
	}

	/*
	 * two attributes below are mandatory only for specific types
	 * of possets, so postpone their validation for posset type
	 * specific functions.
	 */
	if ((attr = get_attr_integer(cmd, FSA_RANDSEED)))
		seed = attr->attr_avd;
	else
		seed = avd_int_alloc(0);

	if ((attr = get_attr_integer(cmd, FSA_RANDMAX)))
		max = attr->attr_avd;
	else
		max = avd_int_alloc(0);

	filebench_log(LOG_INFO,"Defining position set: %s type: %s",
				 avd_get_str(name), avd_get_str(type));

	ps = posset_alloc(name, type, seed, max, entries);
	if (!ps) {
		filebench_log(LOG_ERROR, "Cannot define fileset");
		filebench_shutdown(1);
		/* NOT REACHABLE */
		return;
	}

	/* printing all positions */
	for (i = 0; i < avd_get_int(ps->ps_entries); i++)
		filebench_log(LOG_INFO,"pos %d: %llu", i, ps->ps_positions[i]);

}

/*
 * Creates and starts all defined procflow processes. The call to
 * procflow_init() results in creation of the requested number of
 * process instances for each previously defined procflow. The
 * child processes exec() a new instance of filebench, passing it
 * the instance number and address of the shared memory region.
 * The child processes will then create their threads and flowops.
 * The routine then unlocks the run_lock to allow all the processes'
 * threads to start and  waits for all of them to begin execution.
 * Finally, it records the start time and resets the event generation
 * system.
 */
static void
parser_proc_create(cmd_t *cmd)
{
	filebench_shm->shm_1st_err = 0;
	filebench_shm->shm_f_abort = FILEBENCH_OK;

	(void) pthread_rwlock_rdlock(&filebench_shm->shm_run_lock);

	if (procflow_init() != 0) {
		filebench_log(LOG_ERROR, "Failed to create processes\n");
		filebench_shutdown(1);
	}

	/* Wait for all threads to start */
	if (procflow_allstarted() != 0) {
		filebench_log(LOG_ERROR, "Could not start run");
		return;
	}

	/* Release the read lock, allowing threads to start */
	(void) pthread_rwlock_unlock(&filebench_shm->shm_run_lock);

	if (filebench_shm->shm_required &&
	    (ipc_ismcreate(filebench_shm->shm_required) < 0)) {
		filebench_log(LOG_ERROR, "Could not allocate shared memory");
		return;
	}

	filebench_shm->shm_starttime = gethrtime();
	eventgen_reset();
}

/*
 * Calls fileset_createsets() to populate all filesets and create all
 * associated, initially existant,  files and subdirectories.
 * If errors are encountered, calls filebench_shutdown() to exit Filebench.
 */
static void
parser_fileset_create(cmd_t *cmd)
{
	if (!filecreate_done) {
		filecreate_done = 1;

		if (fileset_createsets()) {
			filebench_log(LOG_ERROR, "Failed to create filesets");
			filebench_shutdown(1);
		}
	} else {
		filebench_log(LOG_INFO,
		    "Attempting to create fileset more than once, ignoring");
	}

}

/*
 * Deletes the files and directories that represent files and filesets on the
 * storage medium.
 */
static void
parser_fileset_shutdown(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Shutting down filesets");
	fileset_delete_all_filesets();
}

/*
 * Shuts down all processes and their associated threads. When finished
 * it deletes interprocess shared memory and resets the event generator.
 * It does not exit the filebench program though.
 */
static void
parser_proc_shutdown(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Shutting down processes");
	filecreate_done = 0;
	procflow_shutdown();
	if (filebench_shm->shm_required)
		ipc_ismdelete();
	eventgen_reset();
}

/*
 * Ends filebench run after first destoring any interprocess
 * shared memory. The call to filebench_shutdown()
 * also causes filebench to exit.
 */
static void
parser_filebench_shutdown(cmd_t *cmd)
{
	int f_abort = filebench_shm->shm_f_abort;

	ipc_fini();

	if (f_abort == FILEBENCH_ABORT_ERROR)
		filebench_shutdown(1);
	else
		filebench_shutdown(0);
}

/*
 * This is Used for timing runs.Pauses the master thread in one second
 * intervals until the supplied ptime runs out or the f_abort flag
 * is raised. If given a time of zero or less, or the mode is stop on
 * lack of resources, it will pause until f_abort is raised.
 */
static int
parser_pause(int ptime)
{
	int timeslept = 0;

	if ((filebench_shm->shm_rmode == FILEBENCH_MODE_TIMEOUT) &&
	    (ptime > 0)) {
		while (timeslept < ptime) {
			(void) sleep(1);
			timeslept++;
			if (filebench_shm->shm_f_abort)
				break;
		}
	} else {
		/* initial runtime of 0 means run till abort */
		/* CONSTCOND */
		while (1) {
			(void) sleep(1);
			timeslept++;
			if (filebench_shm->shm_f_abort)
				break;
		}
	}
	return (timeslept);
}

/*
 * Do a file bench run. Calls routines to create file sets, files, and
 * processes. It resets the statistics counters, then sleeps for the runtime
 * passed as an argument to it on the command line in 1 second increments.
 * When it is finished sleeping, it collects a snapshot of the statistics
 * and ends the run.
 */
static void
parser_run(cmd_t *cmd)
{
	int runtime;
	int timeslept;

	runtime = cmd->cmd_qty;

	parser_fileset_create(cmd);
	parser_proc_create(cmd);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");
	stats_clear();

	timeslept = parser_pause(runtime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
	parser_statssnap(cmd);
	parser_proc_shutdown(cmd);
	parser_filebench_shutdown((cmd_t *)0);
}

/*
 * Similar to parser_run, but gets the sleep time from a variable
 * whose name is supplied as an argument to the command.
 */
static void
parser_run_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int runtime;
	int timeslept;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	runtime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");
	stats_clear();

	timeslept = parser_pause(runtime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
	parser_statssnap(cmd);
	parser_proc_shutdown(cmd);
}

char *usagestr = NULL;

/*
 * Prints usage string if defined, else just a message requesting load of a
 * personality.
 */
static void
parser_help(cmd_t *cmd)
{
	if (usagestr) {
		filebench_log(LOG_INFO, "%s", usagestr);
	} else {
		filebench_log(LOG_INFO,
		    "load <personality> (ls "
		    "%s/workloads for list)", fbbasepath);
	}
}

char *varstr = NULL;

/*
 * Prints the string of all var definitions, if there is one.
 */
static void
parser_printvars(cmd_t *cmd)
{
	char *str, *c;

	if (varstr) {
		str = strdup(varstr);
		for (c = str; *c != '\0'; c++) {
			if ((char)*c == '$')
				*c = ' ';
		}
		filebench_log(LOG_INFO, "%s", str);
		free(str);
	}
}

/*
 * Establishes multi-client synchronization socket with synch server.
 */
static void
parser_enable_mc(cmd_t *cmd)
{
	attr_t *attr;
	char *master;
	char *client;

	if ((attr= get_attr(cmd, FSA_MASTER))) {
		master = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "enable multi: no master specified");
		return;
	}

	if ((attr= get_attr(cmd, FSA_CLIENT))) {
		client = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "enable multi: no client specified");
		return;
	}

	mc_sync_open_sock(master, 8001, client);
}

/*
 * Exchanges multi-client synchronization message with synch server.
 */
static void
parser_domultisync(cmd_t *cmd)
{
	attr_t *attr;
	fbint_t value;

	if ((attr = get_attr(cmd, FSA_VALUE)))
		value = avd_get_int(attr->attr_avd);
	else
		value = 1;

	mc_sync_synchronize((int)value);
}

/*
 * Used by the SET command to add a var and default value string to the
 * varstr string. It allocates a new, larger varstr string, copies the
 * old contents of varstr into it, then adds the new var string on the end.
 */
static void
parser_vars(cmd_t *cmd)
{
	char *string = cmd->cmd_tgt1;
	char *newvars;

	if (string == NULL)
		return;

	if (dofile == DOFILE_TRUE)
		return;

	if (varstr == NULL) {
		newvars = malloc(strlen(string) + 2);
		*newvars = 0;
	} else {
		newvars = malloc(strlen(varstr) + strlen(string) + 2);
		(void) strcpy(newvars, varstr);
	}
	(void) strcat(newvars, string);
	(void) strcat(newvars, " ");

	if (varstr)
		free(varstr);

	varstr = newvars;
}

/*
 * used by the set command to set the integer part of a regular
 * variable, or the appropriate field of a random variable
 */
static void
parser_set_integer(cmd_t *cmd)
{
	var_assign_integer(cmd->cmd_tgt1, cmd->cmd_qty);
}

/*
 * used by the set command to set the integer part of a regular
 * variable from another variable, or the appropriate field of a
 * random variable from another variable
 */
static void
parser_set_var(cmd_t *cmd)
{
	var_assign_var(cmd->cmd_tgt1, cmd->cmd_tgt2);
}

/*
 * Used by the set command to set up for a binary operation of a
 * variable from a var, with an integer
 */
static void
parser_set_var_op_int(cmd_t *cmd)
{
	printf("parser_set_var_op_int: Called\n");
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_SUM_IV,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_MINUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_IV_DIF_INT,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_MUL_IV,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_IV_DIV_INT,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;
	}
}

/*
 * Used by the set command to set up for a binary operation of an
 * integer with a variable from a var
 */
static void
parser_set_int_op_var(cmd_t *cmd)
{
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_SUM_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_MINUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_DIF_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_MUL_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_DIV_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;
	}
}

/*
 * Used by the set command to set up for a binary operation of two
 * variables from other vars.
 */
static void
parser_set_var_op_var(cmd_t *cmd)
{
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_SUM_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_MINUS:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_DIF_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_MUL_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_DIV_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;
	}
}


/*
 * Sleeps for cmd->cmd_qty seconds, one second at a time.
 */
static void
parser_warmup(cmd_t *cmd)
{
	int sleeptime;

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	sleeptime = cmd->cmd_qty;
	filebench_log(LOG_INFO, "Warming up...");

	(void) parser_pause(sleeptime);
}

/*
 * Same as parser_sleep, except the sleep time is obtained from a variable
 * whose name is passed to it as an argument on the command line.
 */
static void
parser_warmup_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int sleeptime;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	sleeptime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Warming up...");

	(void) parser_pause(sleeptime);
}

/*
 * Sleeps for cmd->cmd_qty seconds, one second at a time.
 */
static void
parser_sleep(cmd_t *cmd)
{
	int sleeptime;
	int timeslept;

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	sleeptime = cmd->cmd_qty;
	filebench_log(LOG_INFO, "Running...");

	timeslept = parser_pause(sleeptime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
}

/*
 * Same as parser_sleep, except the sleep time is obtained from a variable
 * whose name is passed to it as an argument on the command line.
 */
static void
parser_sleep_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int sleeptime;
	int timeslept;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	sleeptime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");

	timeslept = parser_pause(sleeptime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
}

/*
 * Parser log prints the values of a list of variables to the log file.
 * The list of variables is placed on the command line, separated
 * by comas and the entire list is enclosed in quotes.
 * For example, if $dir contains "/export/home/tmp" and $filesize = 1048576,
 * then typing: log "$dir, $filesize" prints: log /export/home/tmp, 1048576
 */
static void
parser_log(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE, "log %s", string);
	filebench_log(LOG_LOG, "%s", string);
}

/*
 * Implements the stats directory command. changes the directory for
 * dumping statistics to supplied directory path. For example:
 * 	stats directory /tmp
 * changes the stats directory to "/tmp".
 */
static void
parser_directory(cmd_t *cmd)
{
	char newdir[MAXPATHLEN];
	char *dir;
	int ret;

	if ((dir = parser_list2string(cmd->cmd_param_list)) == NULL) {
		filebench_log(LOG_ERROR, "Cannot interpret directory");
		return;
	}

	*newdir = 0;
	/* Change dir relative to cwd if path not fully qualified */
	if (*dir != '/') {
		(void) strcat(newdir, cwd);
		(void) strcat(newdir, "/");
	}
	(void) strcat(newdir, dir);
	(void) mkdir(newdir, 0755);
	filebench_log(LOG_VERBOSE, "Change dir to %s", newdir);
	ret = chdir(newdir);
	free(dir);
}

#define	PIPE_PARENT 1
#define	PIPE_CHILD  0

/*
 * Runs the quoted unix command as a background process. Intended for
 * running statistics gathering utilities such as mpstat while the filebench
 * workload is running. Also records the pid's of the background processes
 * so that parser_statssnap() can terminate them when the run completes.
 */
static void
parser_statscmd(cmd_t *cmd)
{
	char *string;
	pid_t pid;
	pidlist_t *pidlistent;
	int pipe_fd[2];
	int newstdout;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	if ((pipe(pipe_fd)) < 0) {
		filebench_log(LOG_ERROR, "statscmd pipe failed");
		return;
	}

#ifdef HAVE_FORK1
	if ((pid = fork1()) < 0) {
		filebench_log(LOG_ERROR, "statscmd fork failed");
		return;
	}
#elif HAVE_FORK
	if ((pid = fork()) < 0) {
		filebench_log(LOG_ERROR, "statscmd fork failed");
		return;
	}
#else
	Crash! - Need code to deal with no fork1!
#endif /* HAVE_FORK1 */

	if (pid == 0) {

		setsid();

		filebench_log(LOG_VERBOSE,
		    "Backgrounding %s", string);
		/*
		 * Child
		 * - close stdout
		 * - dup to create new stdout
		 * - close pipe fds
		 */
		(void) close(1);

		if ((newstdout = dup(pipe_fd[PIPE_CHILD])) < 0) {
			filebench_log(LOG_ERROR,
			    "statscmd dup failed: %s",
			    strerror(errno));
		}

		(void) close(pipe_fd[PIPE_PARENT]);
		(void) close(pipe_fd[PIPE_CHILD]);

		if (system(string) < 0) {
			filebench_log(LOG_ERROR,
			    "statscmd exec failed: %s",
			    strerror(errno));
		}
		/* Failed! */
		exit(1);

	} else {

		/* Record pid in pidlist for subsequent reaping by stats snap */
		if ((pidlistent = (pidlist_t *)malloc(sizeof (pidlist_t)))
		    == NULL) {
			filebench_log(LOG_ERROR, "pidlistent malloc failed");
			return;
		}

		pidlistent->pl_pid = pid;
		pidlistent->pl_fd = pipe_fd[PIPE_PARENT];
		(void) close(pipe_fd[PIPE_CHILD]);

		/* Add fileobj to global list */
		if (pidlist == NULL) {
			pidlist = pidlistent;
			pidlistent->pl_next = NULL;
		} else {
			pidlistent->pl_next = pidlist;
			pidlist = pidlistent;
		}
	}
}

/*
 * Launches a shell to run the unix command supplied in the argument.
 * The command should be enclosed in quotes, as in:
 * 	system "rm xyz"
 * which would run the "rm" utility to delete the file "xyz".
 */
static void
parser_system(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Running '%s'", string);

	if (system(string) < 0) {
		filebench_log(LOG_ERROR,
		    "system exec failed: %s",
		    strerror(errno));
		filebench_shutdown(1);
	}
	free(string);
}

/*
 * Echos string supplied with command to the log.
 */
static void
parser_echo(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_INFO, "%s", string);
}

static void parser_fscheck(cmd_t *cmd) {
	return;
}

#if 0
/* XXX: do not support this command for now */
/*
 * Checks to see if the specified data directory exists and it's mounted file
 * system is the correct type.
 */
static void
parser_fscheck(cmd_t *cmd)
{
	int fstype_idx;
	char *pathname = NULL;
	char *filesys = "tmpfs";
	char string[MAXPATHLEN];
	struct statvfs64 statbuf;
	attr_t *attr;

	if (cmd->cmd_attr_list == NULL)
		return;

	for (attr = cmd->cmd_attr_list; attr; attr = attr->attr_next) {

		switch(attr->attr_name) {
		case FSA_PATH:
			pathname = avd_get_str(attr->attr_avd);
			break;
		case FSA_FSTYPE:
			filesys = avd_get_str(attr->attr_avd);
			break;
		}
	}

	if (pathname == NULL)
		return;

	if (statvfs64(pathname, &statbuf) < 0) {
		filebench_log(LOG_ERROR,
		    "%s error with supplied data path name: %s; exiting",
		    strerror(errno), pathname);
		filebench_shutdown(1);
		return;
	}

	if (strncmp(filesys, statbuf.f_basetype, FSTYPSZ) != 0) {
		filebench_log(LOG_ERROR,
		    "File System is of type %s, NOT %s as indicated",
		    statbuf.f_basetype, filesys);
		filebench_shutdown(1);
		return;
	}
}
#endif

/*
 * Checks to see if any filesets need to have their caches flushed, and
 * if so invokes the fs_flush script.
 */
static void
parser_fsflush(cmd_t *cmd)
{
	fileset_t *fileset;
	char **fspathlist;
	char *pathname = NULL;
	char *filesys = NULL;
	char string[MAXPATHLEN];
	attr_t *attr;
	int fsidx;

	if ((attr = cmd->cmd_attr_list) == NULL)
		return;

	/* Get supplied file system type */
	if (attr->attr_name == FSA_FSTYPE)
		filesys = avd_get_str(attr->attr_avd);

	if (filesys == NULL) {
		filebench_log(LOG_ERROR,
		    "FSFLUSH command lacks file system type");
		return;
	}

	/* Check all filesets for any that remain cached and count them*/
	fsidx = 0;
	for (fileset = filebench_shm->shm_filesetlist; fileset != NULL;
	     fileset = fileset->fs_next) {

		if (avd_get_bool(fileset->fs_cached))
			return;

		fsidx++;
	}

	/* allocated space for fileset path pointers */
	fspathlist = (char **)malloc(fsidx * sizeof(char *));

	/* If flushing still required, flush all filesets */
	fsidx = 0;
	for (fileset = filebench_shm->shm_filesetlist; fileset != NULL;
	     fileset = fileset->fs_next) {
		int idx;

		if ((pathname = avd_get_str(fileset->fs_path)) == NULL)
			return;

		for (idx = 0; idx < fsidx; idx++) {
			if (strcmp(pathname, fspathlist[idx]) == 0)
				break;
		}

		if (fsidx == idx) {

			/* found a new path */
			fspathlist[fsidx++] = pathname;

			/* now flush it */
			snprintf(string, MAXPATHLEN,
			    "%s/scripts/fs_flush %s %s", fbbasepath,
			    filesys, pathname);

			if (system(string) < 0) {
				filebench_log(LOG_ERROR,
				    "exec of fs_flush script failed: %s",
				    strerror(errno));
				filebench_shutdown(1);
			}
		}
	}
}

/*
 * Prints out the version of Filebench.
 */
static void
parser_version(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Filebench Version: %s", FILEBENCH_VERSION);
}

/*
 * Sets osprof_enabled option
 */
static void
parser_osprof_enable(cmd_t *cmd)
{
	filebench_shm->osprof_enabled = 1;
	filebench_log(LOG_INFO, "OSprof enabled");
}

/*
 * Resets osprof_enabled option
 */
static void
parser_osprof_disable(cmd_t *cmd)
{
	filebench_shm->osprof_enabled = 0;
	filebench_log(LOG_INFO, "OSprof disabled");
}

/*
 * Adds the string supplied as the argument to the usage command
 * to the end of the string printed by the help command.
 */
static void
parser_usage(cmd_t *cmd)
{
	char *string;
	char *newusage;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	if (dofile == DOFILE_TRUE)
		return;

	if (usagestr == NULL) {
		newusage = malloc(strlen(string) + 2);
		*newusage = 0;
	} else {
		newusage = malloc(strlen(usagestr) + strlen(string) + 2);
		(void) strcpy(newusage, usagestr);
	}
	(void) strcat(newusage, "\n");
	(void) strcat(newusage, string);

	if (usagestr)
		free(usagestr);

	usagestr = newusage;

	filebench_log(LOG_INFO, "%s", string);
}

/*
 * Updates the global dump filename with the filename supplied
 * as the command's argument. Then dumps the statistics of each
 * worker flowop into the dump file, followed by a summary of
 * overall totals.
 */
static void
parser_statsdump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_dump(string);

	free(string);
}

/*
 * Same as statsdump, but outputs in a computer friendly format.
 */
static void
parser_statsmultidump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_multidump(string);

	free(string);
}

/*
 * Same as parser_statsdump, but in xml format.
 */
static void
parser_statsxmldump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_xmldump(string);

	free(string);
}

/*
 * Kills off background statistics collection processes, then takes a snapshot
 * of the filebench run's collected statistics using stats_snap() from
 * stats.c.
 */
static void
parser_statssnap(cmd_t *cmd)
{
	pidlist_t *pidlistent;
	int stat;
	pid_t pid;

	for (pidlistent = pidlist; pidlistent != NULL;
	    pidlistent = pidlistent->pl_next) {
		filebench_log(LOG_VERBOSE, "Killing session %d for pid %d",
		    getsid(pidlistent->pl_pid),
		    pidlistent->pl_pid);
		if (pidlistent->pl_fd)
			(void) close(pidlistent->pl_fd);
#ifdef HAVE_SIGSEND
		sigsend(P_SID, getsid(pidlistent->pl_pid), SIGTERM);
#else
		(void) kill(-1, SIGTERM);
#endif

		/* Close pipe */
		if (pidlistent->pl_fd)
			(void) close(pidlistent->pl_fd);

		/* Wait for cmd and all its children */
		while ((pid = waitpid(pidlistent->pl_pid * -1, &stat, 0)) > 0)
			filebench_log(LOG_DEBUG_IMPL,
			"Waited for pid %d", (int)pid);
	}

	for (pidlistent = pidlist; pidlistent != NULL;
	    pidlistent = pidlistent->pl_next) {
		free(pidlistent);
	}

	pidlist = NULL;
	stats_snap();
}

/*
 * Shutdown filebench.
 */
static void
parser_abort(int arg)
{
	(void) sigignore(SIGINT);
	filebench_log(LOG_INFO, "Aborting...");
	filebench_shutdown(1);
}

/*
 * define a random variable and initialize the distribution parameters
 */
static void
parser_randvar_define(cmd_t *cmd)
{
	var_t		*var;
	randdist_t	*rndp;
	attr_t		*attr;
	char		*name;

	/* Get the name for the random variable */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define randvar: no name specified");
		return;
	}

	if ((var = var_define_randvar(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define randvar: failed for random variable %s",
		    name);
		return;
	}

	rndp = var->var_val.randptr;
	rndp->rnd_type = 0;

	/* Get the source of the random numbers */
	if ((attr = get_attr_integer(cmd, FSA_RANDSRC))) {
		int randsrc = (int)avd_get_int(attr->attr_avd);

		switch (randsrc) {
		case FSV_URAND:
			rndp->rnd_type |= RAND_SRC_URANDOM;
			break;
		case FSV_RAND48:
			rndp->rnd_type |= RAND_SRC_GENERATOR;
			break;
		}
	} else {
		/* default to rand48 random number generator */
		rndp->rnd_type |= RAND_SRC_GENERATOR;
	}

	/* Get the min value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDMIN)))
		rndp->rnd_min = attr->attr_avd;
	else
		rndp->rnd_min = avd_int_alloc(0);

	/* Get the roundoff value for the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDROUND)))
		rndp->rnd_round = attr->attr_avd;
	else
		rndp->rnd_round = avd_int_alloc(0);

	/* Get a tablular probablility distribution if there is one */
	if ((attr = get_attr(cmd, FSA_RANDTABLE))) {
		rndp->rnd_probtabs = (probtabent_t *)(attr->attr_obj);
		rndp->rnd_type |= RAND_TYPE_TABLE;

		/* no need for the rest of the attributes */
		goto randdist_init;
	} else {
		rndp->rnd_probtabs = NULL;
	}

	/* Get the type for the random variable */
	if ((attr = get_attr(cmd, FSA_TYPE))) {
		int disttype = (int)avd_get_int(attr->attr_avd);

		switch (disttype) {
		case FSV_RANDUNI:
			rndp->rnd_type |= RAND_TYPE_UNIFORM;
			break;
		case FSA_RANDGAMMA:
			rndp->rnd_type |= RAND_TYPE_GAMMA;
			break;
		case FSV_RANDTAB:
			filebench_log(LOG_ERROR,
			    "Table distribution type without prob table");
			break;
		}
	} else {
		/* default to gamma distribution type */
		rndp->rnd_type |= RAND_TYPE_GAMMA;
	}

	/* Get the seed for the random variable */
	if ((attr = get_attr_integer(cmd, FSA_RANDSEED)))
		rndp->rnd_seed = attr->attr_avd;
	else
		rndp->rnd_seed = avd_int_alloc(0);

	/* Get the gamma value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDGAMMA)))
		rndp->rnd_gamma = attr->attr_avd;
	else
		rndp->rnd_gamma = avd_int_alloc(1500);

	/* Get the mean value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDMEAN))) {
		rndp->rnd_mean = attr->attr_avd;
	} else if ((rndp->rnd_type & RAND_TYPE_MASK) == RAND_TYPE_GAMMA) {
		rndp->rnd_mean = NULL;
	} else {
		rndp->rnd_mean = avd_int_alloc(0);
	}

randdist_init:
	randdist_init(rndp);
}

/*
 * Set a specified random distribution parameter in a random variable.
 */
static void
parser_randvar_set(cmd_t *cmd)
{
	var_t		*randvar;
	randdist_t	*rndp;
	avd_t	value;

	if ((randvar = var_find_randvar(cmd->cmd_tgt1)) == NULL) {
		filebench_log(LOG_ERROR,
		    "set randvar: failed",
		    cmd->cmd_tgt1);
		return;
	}

	rndp = randvar->var_val.randptr;
	value = cmd->cmd_attr_list->attr_avd;

	switch (cmd->cmd_qty) {
	case FSS_TYPE:
		{
			int disttype = (int)avd_get_int(value);

			rndp->rnd_type &= (~RAND_TYPE_MASK);

			switch (disttype) {
			case FSV_RANDUNI:
				rndp->rnd_type |= RAND_TYPE_UNIFORM;
				break;
			case FSA_RANDGAMMA:
				rndp->rnd_type |= RAND_TYPE_GAMMA;
				break;
			case FSV_RANDTAB:
				rndp->rnd_type |= RAND_TYPE_TABLE;
				break;
			}
			break;
		}

	case FSS_SRC:
		{
			int randsrc = (int)avd_get_int(value);

			rndp->rnd_type &=
			    (~(RAND_SRC_URANDOM | RAND_SRC_GENERATOR));

			switch (randsrc) {
			case FSV_URAND:
				rndp->rnd_type |= RAND_SRC_URANDOM;
				break;
			case FSV_RAND48:
				rndp->rnd_type |= RAND_SRC_GENERATOR;
				break;
			}
			break;
		}

	case FSS_SEED:
		rndp->rnd_seed = value;
		break;

	case FSS_GAMMA:
		rndp->rnd_gamma = value;
		break;

	case FSS_MEAN:
		rndp->rnd_mean = value;
		break;

	case FSS_MIN:
		rndp->rnd_min = value;
		break;

	case FSS_ROUND:
		rndp->rnd_round = value;
		break;

	default:
		filebench_log(LOG_ERROR, "setrandvar: undefined attribute");
	}
}

/*
 * alloc_cmd() allocates the required resources for a cmd_t. On failure, a
 * filebench_log is issued and NULL is returned.
 */
static cmd_t *
alloc_cmd(void)
{
	cmd_t *cmd;

	if ((cmd = malloc(sizeof (cmd_t))) == NULL) {
		filebench_log(LOG_ERROR, "Alloc cmd failed");
		return (NULL);
	}

	(void) memset(cmd, 0, sizeof (cmd_t));

	return (cmd);
}

/*
 * Allocates an attr_t structure and zeros it. Returns NULL on failure, or
 * a pointer to the attr_t.
 */
static attr_t *
alloc_attr(void)
{
	attr_t *attr;

	if ((attr = malloc(sizeof (attr_t))) == NULL) {
		return (NULL);
	}

	(void) memset(attr, 0, sizeof (attr_t));
	return (attr);
}

/*
 * Allocates a probtabent_t structure and zeros it. Returns NULL on failure, or
 * a pointer to the probtabent_t.
 */
static probtabent_t *
alloc_probtabent(void)
{
	probtabent_t *rte;

	if ((rte = malloc(sizeof (probtabent_t))) == NULL) {
		return (NULL);
	}

	(void) memset(rte, 0, sizeof (probtabent_t));
	return (rte);
}

/*
 * Allocates an attr_t structure and puts the supplied var_t into
 * its attr_avd location, and sets its name to FSA_LVAR_ASSIGN
 */
static attr_t *
alloc_lvar_attr(var_t *var)
{
	attr_t *attr;

	if ((attr = alloc_attr()) == NULL)
		return (NULL);

	attr->attr_name = FSA_LVAR_ASSIGN;
	attr->attr_avd = (avd_t)var;

	return (attr);
}


/*
 * Searches the attribute list for the command for the named attribute type.
 * The attribute list is created by the parser from the list of attributes
 * supplied with certain commands, such as the define and flowop commands.
 * Returns a pointer to the attribute structure if the named attribute is
 * found, otherwise returns NULL. If the attribute includes a parameter list,
 * the list is converted to a string and stored in the attr_avd field of
 * the returned attr_t struct.
 */
static attr_t *
get_attr_fileset(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		filebench_log(LOG_DEBUG_IMPL,
		    "attr %d = %d %llx?",
		    attr->attr_name,
		    name,
		    attr->attr_avd);

		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		filebench_log(LOG_DEBUG_SCRIPT, "attr is param list");
		rtn->attr_avd = parser_list2varstring(rtn->attr_param_list);
	}

	return (rtn);
}


/*
 * Searches the attribute list for the command for the named attribute type.
 * The attribute list is created by the parser from the list of attributes
 * supplied with certain commands, such as the define and flowop commands.
 * Returns a pointer to the attribute structure if the named attribute is
 * found, otherwise returns NULL. If the attribute includes a parameter list,
 * the list is converted to a string and stored in the attr_avd field of
 * the returned attr_t struct.
 */
static attr_t *
get_attr(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;
	char *string;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		filebench_log(LOG_DEBUG_IMPL,
		    "attr %d = %d %llx?",
		    attr->attr_name,
		    name,
		    attr->attr_avd);

		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		filebench_log(LOG_DEBUG_SCRIPT, "attr is param list");
		string = parser_list2string(rtn->attr_param_list);
		if (string != NULL) {
			rtn->attr_avd = avd_str_alloc(string);
			filebench_log(LOG_DEBUG_SCRIPT,
			    "attr string %s", string);
		}
	}

	return (rtn);
}

/*
 * Similar to get_attr, but converts the parameter string supplied with the
 * named attribute to an integer and stores the integer in the attr_avd
 * portion of the returned attr_t struct.
 */
static attr_t *
get_attr_integer(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list)
		rtn->attr_avd = parser_list2avd(rtn->attr_param_list);

	return (rtn);
}

/*
 * Similar to get_attr, but converts the parameter string supplied with the
 * named attribute to an integer and stores the integer in the attr_avd
 * portion of the returned attr_t struct. If no parameter string is supplied
 * then it defaults to TRUE (1).
 */
static attr_t *
get_attr_bool(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		rtn->attr_avd = parser_list2avd(rtn->attr_param_list);

	} else if (rtn->attr_avd == NULL) {
		rtn->attr_avd = avd_bool_alloc(TRUE);
	}

	/* boolean attributes cannot point to random variables */
	if (AVD_IS_RANDOM(rtn->attr_avd)) {
		filebench_log(LOG_ERROR,
		    "define flowop: Boolean attr %s cannot be random", name);
		filebench_shutdown(1);
		return (NULL);
	}

	return (rtn);
}

/*
 * removes the newly allocated local var from the shared local var
 * list, then puts it at the head of the private local var list
 * supplied as the second argument.
 */
static void
add_lvar_to_list(var_t *newlvar, var_t **lvar_list)
{
	var_t *prev;

	/* remove from shared local list, if there */
	if (newlvar == filebench_shm->shm_var_loc_list) {
		/* on top of list, just grap */
		filebench_shm->shm_var_loc_list = newlvar->var_next;
	} else {
		/* find newvar on list and remove */
		for (prev = filebench_shm->shm_var_loc_list; prev;
		    prev = prev->var_next) {
			if (prev->var_next == newlvar)
				prev->var_next = newlvar->var_next;
		}
	}
	newlvar->var_next = NULL;

	/* add to flowop private local list at head */
	newlvar->var_next = *lvar_list;
	*lvar_list = newlvar;
}

/*
 * Searches the attribute list for the command for any allocated local
 * variables. The attribute list is created by the parser from the list of
 * attributes supplied with certain commands, such as the define and flowop
 * commands. Places all found local vars onto the flowop's local variable
 * list. 
 */
static void
get_attr_lvars(cmd_t *cmd, flowop_t *flowop)
{
	attr_t *attr;
	var_t *orig_lvar_list;

	/* save the local var list */
	orig_lvar_list = flowop->fo_lvar_list;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {

		if (attr->attr_name == FSA_LVAR_ASSIGN) {
			var_t *newvar;

			if ((newvar = (var_t *)attr->attr_avd) == NULL)
				continue;

			add_lvar_to_list(newvar, &flowop->fo_lvar_list);
			var_update_comp_lvars(newvar, orig_lvar_list, NULL);
		}
	}
}

/*
 * Allocates memory for a list_t structure, initializes it to zero, and
 * returns a pointer to it. On failure, returns NULL.
 */
static list_t *
alloc_list()
{
	list_t *list;

	if ((list = malloc(sizeof (list_t))) == NULL) {
		return (NULL);
	}

	(void) memset(list, 0, sizeof (list_t));
	return (list);
}

int
yywrap()
{
	if (parentscript) {
		yyin = parentscript;
		yy_switchfilescript(yyin);
		parentscript = NULL;
		return (0);
	} else
		return (1);
}
#line 4529 "parser_gram.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(void)
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = yyssp - yyss;
    newss = (yyss != 0)
          ? (short *)realloc(yyss, newsize * sizeof(*newss))
          : (short *)malloc(newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    yyss  = newss;
    yyssp = newss + i;
    newvs = (yyvs != 0)
          ? (YYSTYPE *)realloc(yyvs, newsize * sizeof(*newvs))
          : (YYSTYPE *)malloc(newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse(void)
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    yyerror("syntax error");

#ifdef lint
    goto yyerrlab;
#endif

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yyvsp[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 1:
#line 257 "parser_gram.y"
{
	if (yyvsp[0].cmd->cmd != NULL)
		yyvsp[0].cmd->cmd(yyvsp[0].cmd);

	free(yyvsp[0].cmd);
}
break;
case 2:
#line 264 "parser_gram.y"
{
	if (dofile == DOFILE_TRUE)
		YYABORT;
}
break;
case 4:
#line 271 "parser_gram.y"
{
	filebench_log(LOG_DEBUG_IMPL, "inner_command %zx", yyvsp[0].cmd);
	yyval.cmd = yyvsp[0].cmd;
}
break;
case 5:
#line 276 "parser_gram.y"
{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yyvsp[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yyvsp[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "inner_commands adding cmd %zx to list %zx", yyvsp[0].cmd, yyvsp[-1].cmd);

	yyval.cmd = yyvsp[-1].cmd;
}
break;
case 37:
#line 327 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	filebench_log(LOG_DEBUG_IMPL, "foreach_command %zx", yyval.cmd);
}
break;
case 38:
#line 333 "parser_gram.y"
{
	cmd_t *inner_cmd;
	list_t *list;

	yyval.cmd = yyvsp[-6].cmd;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_tgt1 = yyvsp[-5].sval;
	yyval.cmd->cmd_param_list = yyvsp[-3].list;
	yyval.cmd->cmd = parser_foreach_integer;

	for (list = yyval.cmd->cmd_param_list; list != NULL;
	    list = list->list_next) {
		for (inner_cmd = yyval.cmd->cmd_list;
		    inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			filebench_log(LOG_DEBUG_IMPL,
			    "packing foreach: %zx %s=%llu, cmd %zx",
			    yyval.cmd, yyval.cmd->cmd_tgt1,
			    (u_longlong_t)avd_get_int(list->list_integer),
			    inner_cmd);
		}
	}
}
break;
case 39:
#line 356 "parser_gram.y"
{
	cmd_t *inner_cmd;
	list_t *list;

	yyval.cmd = yyvsp[-6].cmd;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_tgt1 = yyvsp[-5].sval;
	yyval.cmd->cmd_param_list = yyvsp[-3].list;
	yyval.cmd->cmd = parser_foreach_string;

	for (list = yyval.cmd->cmd_param_list; list != NULL;
	    list = list->list_next) {
		for (inner_cmd = yyval.cmd->cmd_list;
		    inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			filebench_log(LOG_DEBUG_IMPL,
			    "packing foreach: %zx %s=%s, cmd %zx",
			    yyval.cmd,
			    yyval.cmd->cmd_tgt1,
			    *list->list_string, inner_cmd);
		}
	}
}
break;
case 40:
#line 381 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);
}
break;
case 41:
#line 388 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 42:
#line 406 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);
}
break;
case 43:
#line 413 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);

	/* Find end of list */
	for (list = yyvsp[-4].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-4].list;
}
break;
case 44:
#line 431 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_eventgen;
}
break;
case 45:
#line 437 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 46:
#line 442 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_system;
}
break;
case 47:
#line 451 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_echo;
}
break;
case 48:
#line 460 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_version;
}
break;
case 49:
#line 467 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_osprof_enable;
}
break;
case 50:
#line 474 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_osprof_disable;
}
break;
case 51:
#line 481 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_usage;
}
break;
case 52:
#line 490 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_printvars;
}
break;
case 53:
#line 498 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_enable_mc;
}
break;
case 54:
#line 505 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 55:
#line 510 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_domultisync;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 56:
#line 519 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;
	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 57:
#line 525 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 58:
#line 543 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 59:
#line 550 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 60:
#line 558 "parser_gram.y"
{
	yyval.list = yyvsp[0].list;
}
break;
case 61:
#line 561 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 62:
#line 579 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 63:
#line 596 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 64:
#line 614 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 65:
#line 633 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 66:
#line 640 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 67:
#line 648 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 68:
#line 666 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 69:
#line 683 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);
	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 70:
#line 701 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 71:
#line 719 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 72:
#line 736 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);
	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 73:
#line 754 "parser_gram.y"
{
	yyval.list = yyvsp[-1].list;
}
break;
case 74:
#line 757 "parser_gram.y"
{
	yyval.list = yyvsp[-1].list;
}
break;
case 75:
#line 762 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_list;
}
break;
case 76:
#line 768 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd = &parser_flowop_list;
}
break;
case 77:
#line 773 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fscheck;

	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 78:
#line 781 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list->attr_next = yyvsp[0].attr;
}
break;
case 79:
#line 786 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fsflush;

	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 80:
#line 795 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_log;
	yyval.cmd->cmd_param_list = yyvsp[0].list;
}
break;
case 81:
#line 803 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
	filebench_shm->shm_debug_level = yyvsp[0].ival;
	if (filebench_shm->shm_debug_level > 9)
		yydebug = 1;
}
break;
case 84:
#line 817 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
	if (parentscript) {
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = parser_set_integer;
}
break;
case 85:
#line 827 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_var(yyvsp[-2].sval, yyvsp[0].sval);
	yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
	yyval.cmd->cmd_tgt2 = yyvsp[0].sval;
	if (parentscript) {
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = parser_set_var;
}
break;
case 86:
#line 839 "parser_gram.y"
{
	if (yyvsp[-2].cmd->cmd == parser_set_integer) {
		switch (yyvsp[-1].ival) {
		case FSK_PLUS:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty + yyvsp[0].ival);
			break;
		case FSK_MINUS:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty - yyvsp[0].ival);
			break;
		case FSK_MULTIPLY:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty * yyvsp[0].ival);
			break;
		case FSK_DIVIDE:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty / yyvsp[0].ival);
			break;
		}
		yyval.cmd->cmd = NULL;
	} else {
		yyvsp[-2].cmd->cmd_qty = yyvsp[0].ival;
		yyvsp[-2].cmd->cmd_subtype = yyvsp[-1].ival;
		yyvsp[-2].cmd->cmd = parser_set_var_op_int;
	}
}
break;
case 87:
#line 863 "parser_gram.y"
{
	yyvsp[-2].cmd->cmd_tgt3 = yyvsp[0].sval;
	yyvsp[-2].cmd->cmd_subtype = yyvsp[-1].ival;
	if (yyvsp[-2].cmd->cmd == parser_set_integer) {
		yyval.cmd->cmd = parser_set_int_op_var;
	} else {
		yyvsp[-2].cmd->cmd = parser_set_var_op_var;
	}
}
break;
case 88:
#line 874 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_boolean(yyvsp[-2].sval, yyvsp[0].bval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 89:
#line 885 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_string(yyvsp[-4].sval, yyvsp[-1].sval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yyvsp[-4].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 90:
#line 895 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_string(yyvsp[-2].sval, yyvsp[0].sval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 91:
#line 905 "parser_gram.y"
{
	filebench_shm->shm_rmode = FILEBENCH_MODE_TIMEOUT;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 92:
#line 911 "parser_gram.y"
{
	filebench_shm->shm_rmode = FILEBENCH_MODE_QALLDONE;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 93:
#line 917 "parser_gram.y"
{
	filebench_shm->shm_rmode = FILEBENCH_MODE_Q1STDONE;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 94:
#line 923 "parser_gram.y"
{
	filebench_shm->shm_mmode |= FILEBENCH_MODE_NOUSAGE;
	filebench_log(LOG_INFO, "disabling CPU usage statistics");
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 95:
#line 930 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yyvsp[-3].sval;
	yyval.cmd->cmd_qty = FSS_TYPE;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;

}
break;
case 96:
#line 939 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yyvsp[-3].sval;
	yyval.cmd->cmd_qty = FSS_SRC;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;

}
break;
case 97:
#line 948 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yyvsp[-3].sval;
	yyval.cmd->cmd_qty = yyvsp[-2].ival;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
	
}
break;
case 98:
#line 959 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = (void (*)(struct cmd *))&parser_statssnap;
	break;

}
break;
case 99:
#line 967 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = (void (*)(struct cmd *))&stats_clear;

}
break;
case 100:
#line 974 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = (void (*)(struct cmd *))&parser_directory;

}
break;
case 101:
#line 982 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statscmd;

}
break;
case 102:
#line 990 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statsdump;
}
break;
case 103:
#line 997 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statsxmldump;
}
break;
case 104:
#line 1004 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statsmultidump;
}
break;
case 105:
#line 1013 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_filebench_shutdown;
}
break;
case 106:
#line 1020 "parser_gram.y"
{
	yyval.cmd = yyvsp[0].cmd;
}
break;
case 107:
#line 1023 "parser_gram.y"
{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yyvsp[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yyvsp[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "flowop_list adding cmd %zx to list %zx", yyvsp[0].cmd, yyvsp[-1].cmd);

	yyval.cmd = yyvsp[-1].cmd;
}
break;
case 108:
#line 1041 "parser_gram.y"
{
	/*
	 * Allocate a cmd node per thread, with a
	 * list of flowops attached to the cmd_list
	 */
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_attr_list = yyvsp[-3].attr;
}
break;
case 109:
#line 1053 "parser_gram.y"
{
	yyval.cmd = yyvsp[0].cmd;
}
break;
case 110:
#line 1056 "parser_gram.y"
{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yyvsp[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yyvsp[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "thread_list adding cmd %zx to list %zx", yyvsp[0].cmd, yyvsp[-1].cmd);

	yyval.cmd = yyvsp[-1].cmd;
}
break;
case 111:
#line 1074 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_proc_define;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_attr_list = yyvsp[-3].attr;

}
break;
case 112:
#line 1083 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 113:
#line 1088 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_file_define;
}
break;
case 114:
#line 1093 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fileset_define;
}
break;
case 115:
#line 1099 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 116:
#line 1104 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_posset_define;
}
break;
case 117:
#line 1109 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 118:
#line 1114 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_define;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 119:
#line 1122 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_composite_flowop_define;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_attr_list = yyvsp[-3].attr;
}
break;
case 120:
#line 1130 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 121:
#line 1135 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	switch (yyvsp[0].ival) {
	case FSE_PROC:
		yyval.cmd->cmd = &parser_proc_create;
		break;
	case FSE_FILESET:
	case FSE_FILE:
		yyval.cmd->cmd = &parser_fileset_create;
		break;
	default:
		filebench_log(LOG_ERROR, "unknown entity", yyvsp[0].ival);
		YYERROR;
	}

}
break;
case 122:
#line 1154 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	switch (yyvsp[0].ival) {
	case FSE_PROC:
		yyval.cmd->cmd = &parser_proc_shutdown;
		break;
	case FSE_FILE:
	case FSE_FILESET:
		yyval.cmd->cmd = &parser_fileset_shutdown;
		break;
	default:
		filebench_log(LOG_ERROR, "unknown entity", yyvsp[0].ival);
		YYERROR;
	}

}
break;
case 123:
#line 1173 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_warmup;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
}
break;
case 124:
#line 1180 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_warmup_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yyvsp[0].sval);
}
break;
case 125:
#line 1188 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_sleep;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
}
break;
case 126:
#line 1195 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_sleep_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yyvsp[0].sval);
}
break;
case 127:
#line 1203 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
}
break;
case 128:
#line 1210 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yyvsp[0].sval);
}
break;
case 129:
#line 1217 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run;
	yyval.cmd->cmd_qty = 60UL;
}
break;
case 130:
#line 1225 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_help;
}
break;
case 131:
#line 1232 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_name = fb_stralloc(yyvsp[0].sval);
}
break;
case 132:
#line 1238 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 133:
#line 1243 "parser_gram.y"
{
	FILE *newfile;
	char loadfile[128];

	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	(void) strcpy(loadfile, yyvsp[0].sval);
	(void) strcat(loadfile, ".f");

	if ((newfile = fopen(loadfile, "r")) == NULL) {
		(void) strcpy(loadfile, fbbasepath);
		(void) strcat(loadfile, "/workloads/");
		(void) strcat(loadfile, yyvsp[0].sval);
		(void) strcat(loadfile, ".f");
		if ((newfile = fopen(loadfile, "r")) == NULL) {
			filebench_log(LOG_ERROR, "Cannot open %s", loadfile);
			YYERROR;
		}
	}

	parentscript = yyin;
	yyin = newfile;
	yy_switchfileparent(yyin);
}
break;
case 134:
#line 1270 "parser_gram.y"
{yyval.ival = FSE_PROC;}
break;
case 135:
#line 1271 "parser_gram.y"
{yyval.ival = FSE_THREAD;}
break;
case 136:
#line 1272 "parser_gram.y"
{yyval.ival = FSE_FILESET;}
break;
case 137:
#line 1273 "parser_gram.y"
{yyval.ival = FSE_FILE;}
break;
case 138:
#line 1275 "parser_gram.y"
{ yyval.val.i = yyvsp[0].ival;}
break;
case 139:
#line 1276 "parser_gram.y"
{ yyval.val.s = yyvsp[0].sval;}
break;
case 140:
#line 1277 "parser_gram.y"
{ yyval.val.b = yyvsp[0].bval;}
break;
case 142:
#line 1283 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 143:
#line 1287 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 144:
#line 1301 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 145:
#line 1305 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 146:
#line 1319 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 147:
#line 1324 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 148:
#line 1331 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 149:
#line 1336 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 150:
#line 1344 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 151:
#line 1348 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 152:
#line 1361 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-6].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	
	if ((attr = alloc_attr()) == NULL)
		YYERROR;

	attr->attr_name = FSA_RANDTABLE;
	attr->attr_obj = (void *)yyvsp[-1].rndtb;
	list_end->attr_next = attr;
	yyval.attr = yyvsp[-6].attr;
}
break;
case 153:
#line 1380 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 154:
#line 1385 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 155:
#line 1391 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = FSA_TYPE;
}
break;
case 156:
#line 1396 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = FSA_RANDSRC;
}
break;
case 157:
#line 1402 "parser_gram.y"
{
	if ((yyval.rndtb = alloc_probtabent()) == NULL)
		YYERROR;
	yyval.rndtb->pte_percent = yyvsp[-5].avd;
	yyval.rndtb->pte_segmin  = yyvsp[-3].avd;
	yyval.rndtb->pte_segmax  = yyvsp[-1].avd;
}
break;
case 158:
#line 1412 "parser_gram.y"
{
	yyval.rndtb = yyvsp[0].rndtb;
}
break;
case 159:
#line 1416 "parser_gram.y"
{
	probtabent_t *pte = NULL;
	probtabent_t *ptelist_end = NULL;

	for (pte = yyvsp[-2].rndtb; pte != NULL;
	    pte = pte->pte_next)
		ptelist_end = pte; /* Find end of prob table entry list */

	ptelist_end->pte_next = yyvsp[0].rndtb;

	yyval.rndtb = yyvsp[-2].rndtb;
}
break;
case 160:
#line 1431 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 161:
#line 1435 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 162:
#line 1449 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 163:
#line 1454 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 164:
#line 1462 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 165:
#line 1466 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 166:
#line 1479 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 167:
#line 1493 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 168:
#line 1498 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 169:
#line 1506 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 170:
#line 1510 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 171:
#line 1524 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 172:
#line 1529 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 173:
#line 1537 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 174:
#line 1541 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 175:
#line 1555 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 176:
#line 1561 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = FSA_VALUE;
}
break;
case 177:
#line 1567 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yyvsp[0].sval);
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 178:
#line 1575 "parser_gram.y"
{yyval.ival = FSK_PLUS;}
break;
case 179:
#line 1576 "parser_gram.y"
{yyval.ival = FSK_MINUS;}
break;
case 180:
#line 1577 "parser_gram.y"
{yyval.ival = FSK_MULTIPLY;}
break;
case 181:
#line 1578 "parser_gram.y"
{yyval.ival = FSK_DIVIDE;}
break;
case 189:
#line 1593 "parser_gram.y"
{ yyval.ival = FSA_NICE;}
break;
case 190:
#line 1594 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 191:
#line 1595 "parser_gram.y"
{ yyval.ival = FSA_INSTANCES;}
break;
case 192:
#line 1598 "parser_gram.y"
{ yyval.ival = FSA_SIZE;}
break;
case 193:
#line 1599 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 194:
#line 1600 "parser_gram.y"
{ yyval.ival = FSA_PATH;}
break;
case 195:
#line 1601 "parser_gram.y"
{ yyval.ival = FSA_READONLY;}
break;
case 196:
#line 1602 "parser_gram.y"
{ yyval.ival = FSA_TRUSTTREE;}
break;
case 197:
#line 1603 "parser_gram.y"
{ yyval.ival = FSA_REUSE;}
break;
case 198:
#line 1604 "parser_gram.y"
{ yyval.ival = FSA_PREALLOC;}
break;
case 199:
#line 1605 "parser_gram.y"
{ yyval.ival = FSA_PARALLOC;}
break;
case 200:
#line 1606 "parser_gram.y"
{ yyval.ival = FSA_WRITEONLY;}
break;
case 201:
#line 1609 "parser_gram.y"
{ yyval.ival = FSA_SIZE;}
break;
case 202:
#line 1610 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 203:
#line 1611 "parser_gram.y"
{ yyval.ival = FSA_PATH;}
break;
case 204:
#line 1612 "parser_gram.y"
{ yyval.ival = FSA_DIRWIDTH;}
break;
case 205:
#line 1613 "parser_gram.y"
{ yyval.ival = FSA_DIRDEPTHRV;}
break;
case 206:
#line 1614 "parser_gram.y"
{ yyval.ival = FSA_PREALLOC;}
break;
case 207:
#line 1615 "parser_gram.y"
{ yyval.ival = FSA_PARALLOC;}
break;
case 208:
#line 1616 "parser_gram.y"
{ yyval.ival = FSA_REUSE;}
break;
case 209:
#line 1617 "parser_gram.y"
{ yyval.ival = FSA_READONLY;}
break;
case 210:
#line 1618 "parser_gram.y"
{ yyval.ival = FSA_TRUSTTREE;}
break;
case 211:
#line 1619 "parser_gram.y"
{ yyval.ival = FSA_FILESIZEGAMMA;}
break;
case 212:
#line 1620 "parser_gram.y"
{ yyval.ival = FSA_DIRGAMMA;}
break;
case 213:
#line 1621 "parser_gram.y"
{ yyval.ival = FSA_CACHED;}
break;
case 214:
#line 1622 "parser_gram.y"
{ yyval.ival = FSA_ENTRIES;}
break;
case 215:
#line 1623 "parser_gram.y"
{ yyval.ival = FSA_LEAFDIRS;}
break;
case 216:
#line 1624 "parser_gram.y"
{ yyval.ival = FSA_WRITEONLY;}
break;
case 217:
#line 1627 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 218:
#line 1628 "parser_gram.y"
{ yyval.ival = FSA_TYPE;}
break;
case 219:
#line 1629 "parser_gram.y"
{ yyval.ival = FSA_RANDSEED;}
break;
case 220:
#line 1630 "parser_gram.y"
{ yyval.ival = FSA_ENTRIES;}
break;
case 221:
#line 1631 "parser_gram.y"
{ yyval.ival = FSA_RANDMAX;}
break;
case 222:
#line 1634 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 223:
#line 1635 "parser_gram.y"
{ yyval.ival = FSA_RANDSEED;}
break;
case 224:
#line 1636 "parser_gram.y"
{ yyval.ival = FSA_RANDGAMMA;}
break;
case 225:
#line 1637 "parser_gram.y"
{ yyval.ival = FSA_RANDMEAN;}
break;
case 226:
#line 1638 "parser_gram.y"
{ yyval.ival = FSA_RANDMIN;}
break;
case 227:
#line 1639 "parser_gram.y"
{ yyval.ival = FSA_RANDROUND;}
break;
case 228:
#line 1642 "parser_gram.y"
{ yyval.ival = FSS_TYPE;}
break;
case 229:
#line 1643 "parser_gram.y"
{ yyval.ival = FSS_SRC;}
break;
case 230:
#line 1644 "parser_gram.y"
{ yyval.ival = FSS_SEED;}
break;
case 231:
#line 1645 "parser_gram.y"
{ yyval.ival = FSS_GAMMA;}
break;
case 232:
#line 1646 "parser_gram.y"
{ yyval.ival = FSS_MEAN;}
break;
case 233:
#line 1647 "parser_gram.y"
{ yyval.ival = FSS_MIN;}
break;
case 234:
#line 1648 "parser_gram.y"
{ yyval.ival = FSS_ROUND;}
break;
case 235:
#line 1651 "parser_gram.y"
{ yyval.ival = FSS_SEED;}
break;
case 236:
#line 1652 "parser_gram.y"
{ yyval.ival = FSS_GAMMA;}
break;
case 237:
#line 1653 "parser_gram.y"
{ yyval.ival = FSS_MEAN;}
break;
case 238:
#line 1654 "parser_gram.y"
{ yyval.ival = FSS_MIN;}
break;
case 239:
#line 1655 "parser_gram.y"
{ yyval.ival = FSS_ROUND;}
break;
case 240:
#line 1658 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 241:
#line 1665 "parser_gram.y"
{ yyval.ival = FSV_RANDUNI;}
break;
case 242:
#line 1666 "parser_gram.y"
{ yyval.ival = FSV_RANDTAB;}
break;
case 243:
#line 1667 "parser_gram.y"
{ yyval.ival = FSA_RANDGAMMA;}
break;
case 244:
#line 1670 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 245:
#line 1677 "parser_gram.y"
{ yyval.ival = FSV_URAND;}
break;
case 246:
#line 1678 "parser_gram.y"
{ yyval.ival = FSV_RAND48;}
break;
case 247:
#line 1681 "parser_gram.y"
{ yyval.ival = FSA_PROCESS;}
break;
case 248:
#line 1682 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 249:
#line 1683 "parser_gram.y"
{ yyval.ival = FSA_MEMSIZE;}
break;
case 250:
#line 1684 "parser_gram.y"
{ yyval.ival = FSA_USEISM;}
break;
case 251:
#line 1685 "parser_gram.y"
{ yyval.ival = FSA_INSTANCES;}
break;
case 252:
#line 1686 "parser_gram.y"
{ yyval.ival = FSA_IOPRIO;}
break;
case 253:
#line 1689 "parser_gram.y"
{ yyval.ival = FSA_WSS;}
break;
case 254:
#line 1690 "parser_gram.y"
{ yyval.ival = FSA_FILE;}
break;
case 255:
#line 1691 "parser_gram.y"
{ yyval.ival = FSA_POSSET;}
break;
case 256:
#line 1692 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 257:
#line 1693 "parser_gram.y"
{ yyval.ival = FSA_RANDOM;}
break;
case 258:
#line 1694 "parser_gram.y"
{ yyval.ival = FSA_FD;}
break;
case 259:
#line 1695 "parser_gram.y"
{ yyval.ival = FSA_SRCFD;}
break;
case 260:
#line 1696 "parser_gram.y"
{ yyval.ival = FSA_ROTATEFD;}
break;
case 261:
#line 1697 "parser_gram.y"
{ yyval.ival = FSA_DSYNC;}
break;
case 262:
#line 1698 "parser_gram.y"
{ yyval.ival = FSA_DIRECTIO;}
break;
case 263:
#line 1699 "parser_gram.y"
{ yyval.ival = FSA_INDEXED;}
break;
case 264:
#line 1700 "parser_gram.y"
{ yyval.ival = FSA_TARGET;}
break;
case 265:
#line 1701 "parser_gram.y"
{ yyval.ival = FSA_ITERS;}
break;
case 266:
#line 1702 "parser_gram.y"
{ yyval.ival = FSA_VALUE;}
break;
case 267:
#line 1703 "parser_gram.y"
{ yyval.ival = FSA_BLOCKING;}
break;
case 268:
#line 1704 "parser_gram.y"
{ yyval.ival = FSA_HIGHWATER;}
break;
case 269:
#line 1705 "parser_gram.y"
{ yyval.ival = FSA_IOSIZE;}
break;
case 270:
#line 1706 "parser_gram.y"
{ yyval.ival = FSA_NOREADAHEAD;}
break;
case 271:
#line 1709 "parser_gram.y"
{ yyval.ival = FSA_RATE;}
break;
case 272:
#line 1712 "parser_gram.y"
{ yyval.ival = FSA_MASTER;}
break;
case 273:
#line 1713 "parser_gram.y"
{ yyval.ival = FSA_CLIENT;}
break;
case 274:
#line 1716 "parser_gram.y"
{ yyval.ival = FSA_PATH;}
break;
case 275:
#line 1717 "parser_gram.y"
{ yyval.ival = FSA_FSTYPE;}
break;
case 276:
#line 1720 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 277:
#line 1724 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 278:
#line 1737 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 279:
#line 1751 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 280:
#line 1757 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_boolean(yyvsp[-2].sval, yyvsp[0].bval))) == NULL)
		YYERROR;
}
break;
case 281:
#line 1762 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_integer(yyvsp[-2].sval, yyvsp[0].ival))) == NULL)
		YYERROR;
}
break;
case 282:
#line 1767 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_string(yyvsp[-4].sval, yyvsp[-1].sval))) == NULL)
		YYERROR;
}
break;
case 283:
#line 1772 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_string(yyvsp[-2].sval, yyvsp[0].sval))) == NULL)
		YYERROR;
}
break;
case 284:
#line 1777 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_var(yyvsp[-2].sval, yyvsp[0].sval))) == NULL)
		YYERROR;
}
break;
case 285:
#line 1782 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_alloc_local(yyvsp[0].sval))) == NULL)
		YYERROR;
}
break;
case 286:
#line 1789 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 287:
#line 1790 "parser_gram.y"
{ yyval.ival = FSA_ITERS;}
break;
case 288:
#line 1793 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yyvsp[0].sval);
}
break;
case 289:
#line 1797 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 290:
#line 1801 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_bool_alloc(yyvsp[0].bval);
}
break;
case 291:
#line 1805 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = var_ref_attr(yyvsp[0].sval);
}
break;
case 292:
#line 1811 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_param_list = yyvsp[0].list;
}
break;
case 293:
#line 1815 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yyvsp[0].sval);
}
break;
case 294:
#line 1819 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 295:
#line 1823 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_bool_alloc(yyvsp[0].bval);
}
break;
case 296:
#line 1827 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = var_ref_attr(yyvsp[0].sval);
}
break;
case 297:
#line 1834 "parser_gram.y"
{
	yyval.avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 298:
#line 1837 "parser_gram.y"
{
	yyval.avd = var_ref_attr(yyvsp[0].sval);
}
break;
#line 6783 "parser_gram.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;

yyoverflow:
    yyerror("yacc stack overflow");

yyabort:
    return (1);

yyaccept:
    return (0);
}
